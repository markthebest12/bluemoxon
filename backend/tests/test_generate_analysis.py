"""Generate analysis API tests."""

from unittest.mock import patch, MagicMock
import pytest


class TestGenerateAnalysis:
    """Tests for POST /api/v1/books/{id}/analysis/generate."""

    def test_generate_analysis_book_not_found(self, client):
        """Test 404 when book doesn't exist."""
        response = client.post("/api/v1/books/999/analysis/generate")
        assert response.status_code == 404

    @patch("app.api.v1.books.invoke_bedrock")
    @patch("app.api.v1.books.fetch_book_images_for_bedrock")
    @patch("app.api.v1.books.fetch_source_url_content")
    def test_generate_analysis_success(
        self,
        mock_fetch_url,
        mock_fetch_images,
        mock_invoke,
        client,
    ):
        """Test successful analysis generation."""
        # Setup mocks
        mock_fetch_url.return_value = None
        mock_fetch_images.return_value = []
        mock_invoke.return_value = """# Executive Summary

This is a test analysis generated by Bedrock.

## Condition Assessment

The book is in very good condition.
"""

        # Create a book
        response = client.post("/api/v1/books", json={"title": "Test Book"})
        book_id = response.json()["id"]

        # Generate analysis
        response = client.post(f"/api/v1/books/{book_id}/analysis/generate")
        assert response.status_code == 200
        data = response.json()
        assert data["book_id"] == book_id
        assert "Executive Summary" in data["full_markdown"]
        assert data["model_used"] is not None

    @patch("app.api.v1.books.invoke_bedrock")
    @patch("app.api.v1.books.fetch_book_images_for_bedrock")
    @patch("app.api.v1.books.fetch_source_url_content")
    def test_generate_analysis_replaces_existing(
        self,
        mock_fetch_url,
        mock_fetch_images,
        mock_invoke,
        client,
    ):
        """Test that generating analysis replaces existing."""
        mock_fetch_url.return_value = None
        mock_fetch_images.return_value = []
        mock_invoke.return_value = "# New Analysis\n\nReplacement content."

        # Create a book with existing analysis
        response = client.post("/api/v1/books", json={"title": "Test Book"})
        book_id = response.json()["id"]

        # Add initial analysis
        client.put(
            f"/api/v1/books/{book_id}/analysis",
            content="# Old Analysis",
            headers={"Content-Type": "text/plain"},
        )

        # Generate new analysis (should replace)
        response = client.post(f"/api/v1/books/{book_id}/analysis/generate")
        assert response.status_code == 200

        # Verify old analysis was replaced
        response = client.get(f"/api/v1/books/{book_id}/analysis/raw")
        assert "New Analysis" in response.text
        assert "Old Analysis" not in response.text

    def test_generate_analysis_model_selection(self, client):
        """Test model parameter is accepted."""
        # Create a book
        response = client.post("/api/v1/books", json={"title": "Test Book"})
        book_id = response.json()["id"]

        # Test with opus model (will fail without mock, but validates param handling)
        with patch("app.api.v1.books.invoke_bedrock") as mock_invoke:
            with patch("app.api.v1.books.fetch_book_images_for_bedrock") as mock_images:
                with patch("app.api.v1.books.fetch_source_url_content") as mock_url:
                    mock_url.return_value = None
                    mock_images.return_value = []
                    mock_invoke.return_value = "# Test"

                    response = client.post(
                        f"/api/v1/books/{book_id}/analysis/generate",
                        json={"model": "opus"},
                    )
                    assert response.status_code == 200

                    # Verify opus model was requested
                    call_args = mock_invoke.call_args
                    assert call_args[1]["model"] == "opus"
