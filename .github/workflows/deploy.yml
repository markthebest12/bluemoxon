# Deploy Pipeline - Deploys to staging/production based on branch
# Uses AWS OIDC for secure, keyless authentication
#
# Workflow:
#   push to staging → deploy to staging environment
#   push to main    → deploy to production environment

name: Deploy

on:
  push:
    branches: [main, staging]
    paths-ignore:
      - '**.md'
      - 'docs/**'
      - '.github/dependabot.yml'
      - 'LICENSE'
      - '.gitignore'
  workflow_dispatch:  # Allow manual trigger

# Only one deployment at a time per environment
concurrency:
  group: deploy-${{ github.ref_name }}
  cancel-in-progress: false

env:
  AWS_REGION: us-west-2
  PYTHON_VERSION: "3.11"
  NODE_VERSION: "20"
  # Auto-generated version: YYYY.MM.DD-<short-sha>
  APP_VERSION: ""  # Set dynamically in generate-version job

# Required for AWS OIDC authentication, release tagging, and drift issues
permissions:
  id-token: write
  contents: write  # Required for creating release tags
  issues: write    # Required for creating/updating drift issues

jobs:
  # ============================================
  # CI Checks (must pass before deploy)
  # ============================================

  ci:
    name: CI Checks
    uses: ./.github/workflows/ci.yml

  # ============================================
  # Environment Configuration
  # ============================================

  configure:
    name: Configure Environment
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.env.outputs.environment }}
      drift_detected: ${{ steps.drift.outputs.drift_detected }}
      aws_account_id: ${{ steps.config.outputs.aws_account_id }}
      lambda_function_name: ${{ steps.config.outputs.lambda_function_name }}
      worker_function_name: ${{ steps.config.outputs.worker_function_name }}
      eval_runbook_worker_function_name: ${{ steps.config.outputs.eval_runbook_worker_function_name }}
      scraper_function_name: ${{ steps.config.outputs.scraper_function_name }}
      scraper_ecr_repository: ${{ steps.config.outputs.scraper_ecr_repository }}
      s3_frontend_bucket: ${{ steps.config.outputs.s3_frontend_bucket }}
      cloudfront_distribution_id: ${{ steps.config.outputs.cloudfront_distribution_id }}
      api_url: ${{ steps.config.outputs.api_url }}
      app_url: ${{ steps.config.outputs.app_url }}
      cognito_user_pool_id: ${{ steps.config.outputs.cognito_user_pool_id }}
      cognito_client_id: ${{ steps.config.outputs.cognito_client_id }}
      cognito_domain: ${{ steps.config.outputs.cognito_domain }}
    steps:
      - uses: actions/checkout@v6
        with:
          sparse-checkout: |
            infra/terraform
            infra/config
          sparse-checkout-cone-mode: false

      - name: Determine environment
        id: env
        run: |
          if [[ "${{ github.ref_name }}" == "main" ]]; then
            echo "environment=production" >> $GITHUB_OUTPUT
            echo "tf_backend_bucket=bluemoxon-terraform-state" >> $GITHUB_OUTPUT
            echo "tf_backend_key=bluemoxon/prod/terraform.tfstate" >> $GITHUB_OUTPUT
            echo "tf_dynamodb_table=bluemoxon-terraform-locks" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref_name }}" == "staging" ]]; then
            echo "environment=staging" >> $GITHUB_OUTPUT
            echo "tf_backend_bucket=bluemoxon-terraform-state-staging" >> $GITHUB_OUTPUT
            echo "tf_backend_key=bluemoxon/staging/terraform.tfstate" >> $GITHUB_OUTPUT
            echo "tf_dynamodb_table=bluemoxon-terraform-locks" >> $GITHUB_OUTPUT
          else
            echo "ERROR: Unknown branch ${{ github.ref_name }}"
            exit 1
          fi

      - name: Configure AWS credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ steps.env.outputs.environment == 'production' && secrets.AWS_DEPLOY_ROLE_ARN || secrets.AWS_STAGING_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_wrapper: false

      - name: Initialize Terraform
        working-directory: infra/terraform
        run: |
          terraform init \
            -backend-config="bucket=${{ steps.env.outputs.tf_backend_bucket }}" \
            -backend-config="key=${{ steps.env.outputs.tf_backend_key }}" \
            -backend-config="region=${{ env.AWS_REGION }}" \
            -backend-config="dynamodb_table=${{ steps.env.outputs.tf_dynamodb_table }}"

      - name: Check for infrastructure drift
        id: drift
        working-directory: infra/terraform
        env:
          # Dummy password for plan-only drift check (not applied)
          TF_VAR_db_password: "drift-check-dummy-not-applied"
        run: |
          echo "Running pre-deploy drift check..."
          ENV="${{ steps.env.outputs.environment }}"
          TFVARS_FILE="envs/${{ steps.env.outputs.environment == 'production' && 'prod' || 'staging' }}.tfvars"

          set +e
          set -o pipefail
          terraform plan -detailed-exitcode -var-file="$TFVARS_FILE" -no-color 2>&1 | tee plan-output.txt
          EXIT_CODE=${PIPESTATUS[0]}
          set -e

          if [ $EXIT_CODE -eq 0 ]; then
            echo "✅ No infrastructure drift detected"
            echo "drift_detected=false" >> $GITHUB_OUTPUT
          elif [ $EXIT_CODE -eq 2 ]; then
            # Extract resource counts
            ADDS=$(grep -c "will be created" plan-output.txt || echo "0")
            CHANGES=$(grep -c "will be updated" plan-output.txt || echo "0")
            DESTROYS=$(grep -c "will be destroyed" plan-output.txt || echo "0")

            echo "::warning::Infrastructure drift detected in $ENV: +$ADDS ~$CHANGES -$DESTROYS resources"
            echo "drift_detected=true" >> $GITHUB_OUTPUT
            echo "adds=$ADDS" >> $GITHUB_OUTPUT
            echo "changes=$CHANGES" >> $GITHUB_OUTPUT
            echo "destroys=$DESTROYS" >> $GITHUB_OUTPUT
            echo ""
            echo "⚠️  DRIFT DETECTED - Deployment will continue (warn-only mode)"
            echo "   Resources to add:     $ADDS"
            echo "   Resources to change:  $CHANGES"
            echo "   Resources to destroy: $DESTROYS"
            echo ""
            echo "   Review daily drift-detection workflow for details."
            echo "   Consider running 'terraform apply' after this deployment."
          else
            echo "::warning::Terraform plan failed (exit code $EXIT_CODE) - continuing deployment"
            echo "drift_detected=error" >> $GITHUB_OUTPUT
          fi

          rm -f plan-output.txt

      - name: Create or update drift issue
        if: steps.drift.outputs.drift_detected == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const env = '${{ steps.env.outputs.environment }}';
            const adds = '${{ steps.drift.outputs.adds }}' || '0';
            const changes = '${{ steps.drift.outputs.changes }}' || '0';
            const destroys = '${{ steps.drift.outputs.destroys }}' || '0';
            const runUrl = `${process.env.GITHUB_SERVER_URL}/${process.env.GITHUB_REPOSITORY}/actions/runs/${process.env.GITHUB_RUN_ID}`;
            const commitSha = '${{ github.sha }}';
            const commitMsg = `${{ github.event.head_commit.message }}`.split('\n')[0];
            const branch = '${{ github.ref_name }}';

            // Check for existing open drift issue
            const existingIssues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'drift,infra',
              per_page: 10
            });

            const existingDriftIssue = existingIssues.data.find(
              issue => issue.title.includes(`[${env}]`) && issue.title.includes('Infrastructure Drift')
            );

            if (existingDriftIssue) {
              // Update existing issue with new detection
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: existingDriftIssue.number,
                body: `## Drift Still Present - Pre-Deploy Check

            **Detected during:** Deploy to ${env}
            **Branch:** \`${branch}\`
            **Commit:** [\`${commitSha.substring(0, 7)}\`](${process.env.GITHUB_SERVER_URL}/${process.env.GITHUB_REPOSITORY}/commit/${commitSha}) - ${commitMsg}
            **Date:** ${new Date().toISOString().split('T')[0]}

            | Metric | Count |
            |--------|-------|
            | Resources to add | ${adds} |
            | Resources to change | ${changes} |
            | Resources to destroy | ${destroys} |

            [View workflow run](${runUrl})

            ---
            ⚠️ Deployment continued (warn-only mode)`
              });
              console.log(`Updated existing drift issue #${existingDriftIssue.number}`);
            } else {
              // Create new issue
              const issue = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: `[${env}] Infrastructure Drift Detected (Pre-Deploy)`,
                labels: ['drift', 'infra', 'priority:high'],
                body: `## Infrastructure Drift Detected During Deployment

            **Environment:** ${env}
            **Detected:** ${new Date().toISOString()}
            **Branch:** \`${branch}\`
            **Commit:** [\`${commitSha.substring(0, 7)}\`](${process.env.GITHUB_SERVER_URL}/${process.env.GITHUB_REPOSITORY}/commit/${commitSha}) - ${commitMsg}

            ### Summary
            | Metric | Count |
            |--------|-------|
            | Resources to add | ${adds} |
            | Resources to change | ${changes} |
            | Resources to destroy | ${destroys} |

            ### What Happened
            Pre-deploy drift check detected infrastructure differences. Deployment continued in **warn-only mode**.

            ### Next Steps
            1. Review the [workflow run](${runUrl}) for details
            2. Either:
               - Apply Terraform to fix drift: \`terraform apply -var-file=envs/${env === 'production' ? 'prod' : 'staging'}.tfvars\`
               - Import manual resources: \`terraform import\`
               - Document exception in \`docs/MANUAL_CHANGES.md\`

            ### Root Cause Investigation
            - [ ] Was this a manual AWS console change?
            - [ ] Was this a CLI change without Terraform?
            - [ ] Is this expected (pending Terraform PR)?

            ---
            Related: #235 (Pre-deploy drift check feature)`
              });
              console.log(`Created drift issue #${issue.data.number}`);
            }

      - name: Read Terraform outputs
        id: config
        working-directory: infra/terraform
        run: |
          echo "Reading configuration from Terraform state..."

          # Environment info
          echo "environment=$(terraform output -raw environment)" >> $GITHUB_OUTPUT
          echo "aws_account_id=$(terraform output -raw aws_account_id)" >> $GITHUB_OUTPUT

          # Lambda functions
          echo "lambda_function_name=$(terraform output -raw lambda_function_name)" >> $GITHUB_OUTPUT
          echo "worker_function_name=$(terraform output -raw analysis_worker_function_name)" >> $GITHUB_OUTPUT
          echo "eval_runbook_worker_function_name=$(terraform output -raw eval_runbook_worker_function_name)" >> $GITHUB_OUTPUT

          # Scraper (may not exist in all envs)
          echo "scraper_function_name=$(terraform output -raw scraper_function_name 2>/dev/null || echo '')" >> $GITHUB_OUTPUT
          echo "scraper_ecr_repository=$(terraform output -raw scraper_ecr_repository 2>/dev/null || echo '')" >> $GITHUB_OUTPUT

          # S3 and CloudFront
          echo "s3_frontend_bucket=$(terraform output -raw frontend_bucket_name)" >> $GITHUB_OUTPUT
          echo "cloudfront_distribution_id=$(terraform output -raw frontend_cdn_distribution_id)" >> $GITHUB_OUTPUT

          # URLs
          echo "api_url=$(terraform output -raw api_url)" >> $GITHUB_OUTPUT
          echo "app_url=$(terraform output -raw app_url)" >> $GITHUB_OUTPUT

          # Cognito
          echo "cognito_user_pool_id=$(terraform output -raw cognito_user_pool_id)" >> $GITHUB_OUTPUT
          echo "cognito_client_id=$(terraform output -raw cognito_client_id)" >> $GITHUB_OUTPUT
          echo "cognito_domain=$(terraform output -raw cognito_domain)" >> $GITHUB_OUTPUT

          echo "Configuration loaded from Terraform state"

      - name: Validate config consistency
        working-directory: infra/terraform
        run: |
          # Compare against static config files (warn only, don't fail)
          if [[ "${{ steps.env.outputs.environment }}" == "production" ]]; then
            CONFIG_FILE="../config/production.json"
          else
            CONFIG_FILE="../config/staging.json"
          fi

          echo "Validating against static config: $CONFIG_FILE"

          # Compare key values
          STATIC_POOL_ID=$(jq -r '.cognito.user_pool_id' $CONFIG_FILE 2>/dev/null || echo '')
          TF_POOL_ID="${{ steps.config.outputs.cognito_user_pool_id }}"

          if [[ -n "$STATIC_POOL_ID" && "$STATIC_POOL_ID" != "$TF_POOL_ID" ]]; then
            echo "::warning::Config drift detected: cognito_user_pool_id"
            echo "  Static: $STATIC_POOL_ID"
            echo "  Terraform: $TF_POOL_ID"
          fi

          STATIC_CLIENT_ID=$(jq -r '.cognito.app_client_id' $CONFIG_FILE 2>/dev/null || echo '')
          TF_CLIENT_ID="${{ steps.config.outputs.cognito_client_id }}"

          if [[ -n "$STATIC_CLIENT_ID" && "$STATIC_CLIENT_ID" != "$TF_CLIENT_ID" ]]; then
            echo "::warning::Config drift detected: cognito_client_id"
            echo "  Static: $STATIC_CLIENT_ID"
            echo "  Terraform: $TF_CLIENT_ID"
          fi

          STATIC_LAMBDA=$(jq -r '.lambda.function_name' $CONFIG_FILE 2>/dev/null || echo '')
          TF_LAMBDA="${{ steps.config.outputs.lambda_function_name }}"

          if [[ -n "$STATIC_LAMBDA" && "$STATIC_LAMBDA" != "$TF_LAMBDA" ]]; then
            echo "::warning::Config drift detected: lambda_function_name"
            echo "  Static: $STATIC_LAMBDA"
            echo "  Terraform: $TF_LAMBDA"
          fi

          echo "Validation complete - using Terraform values as source of truth"

  # ============================================
  # Generate Version (auto-generated, no manual maintenance)
  # ============================================

  generate-version:
    name: Generate Version
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      short_sha: ${{ steps.version.outputs.short_sha }}
    steps:
      - name: Generate version string
        id: version
        run: |
          # Format: YYYY.MM.DD-<short-sha>
          DATE=$(date -u +%Y.%m.%d)
          SHORT_SHA=${GITHUB_SHA::7}
          VERSION="${DATE}-${SHORT_SHA}"

          echo "Generated version: $VERSION"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "short_sha=$SHORT_SHA" >> $GITHUB_OUTPUT

  # ============================================
  # Build Lambda Package
  # ============================================

  build-backend:
    name: Build Lambda Package
    runs-on: ubuntu-latest
    needs: [ci, configure, generate-version]

    steps:
      - uses: actions/checkout@v6

      - name: Create VERSION file
        run: |
          echo "${{ needs.generate-version.outputs.version }}" > VERSION
          echo "VERSION file contents: $(cat VERSION)"

      - name: Build Lambda package with Docker
        run: |
          # Use Lambda Python 3.12 image for binary compatibility
          docker run --rm \
            --entrypoint /bin/bash \
            -v ${{ github.workspace }}/backend:/app:ro \
            -v ${{ github.workspace }}/VERSION:/VERSION:ro \
            -v /tmp/lambda-deploy:/output \
            --platform linux/amd64 \
            public.ecr.aws/lambda/python:3.12 \
            -c "
              pip install -q -t /output -r /app/requirements.txt
              cp -r /app/app /output/
              cp /VERSION /output/
            "

      - name: Create deployment zip
        run: |
          cd /tmp/lambda-deploy
          # Note: Keep .dist-info directories - required for importlib.metadata
          # (pydantic uses this to check if email-validator is installed)
          zip -q -r ${{ github.workspace }}/lambda-package.zip . \
            -x "*.pyc" -x "*__pycache__*"

          # Report package size
          ls -lh ${{ github.workspace }}/lambda-package.zip

      - name: Upload Lambda artifact
        uses: actions/upload-artifact@v6
        with:
          name: lambda-package
          path: lambda-package.zip
          retention-days: 1

  # ============================================
  # Build Scraper (Docker)
  # ============================================

  build-scraper:
    name: Build Scraper Image
    runs-on: ubuntu-latest
    needs: [ci, configure, generate-version]
    if: needs.configure.outputs.scraper_function_name != ''

    steps:
      - uses: actions/checkout@v6

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Configure AWS credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ needs.configure.outputs.environment == 'production' && secrets.AWS_DEPLOY_ROLE_ARN || secrets.AWS_STAGING_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push scraper image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ needs.configure.outputs.scraper_ecr_repository }}
          IMAGE_TAG: ${{ needs.generate-version.outputs.version }}
        working-directory: scraper
        run: |
          echo "Building scraper image with VERSION=$IMAGE_TAG"

          # Build with version baked in (no provenance for Lambda compatibility)
          # Note: Don't tag with 'latest' - ECR has tag immutability enabled
          docker build \
            --build-arg VERSION=$IMAGE_TAG \
            --provenance=false \
            --sbom=false \
            -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG \
            .

          # Push versioned tag only
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG

          echo "Pushed: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"

  # ============================================
  # Build Frontend
  # ============================================

  build-frontend:
    name: Build Frontend
    runs-on: ubuntu-latest
    needs: [ci, configure, generate-version]

    steps:
      - uses: actions/checkout@v6

      - name: Create VERSION file
        run: |
          echo "${{ needs.generate-version.outputs.version }}" > VERSION
          echo "VERSION file contents: $(cat VERSION)"

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Install dependencies
        working-directory: frontend
        run: npm ci

      - name: Build for ${{ needs.configure.outputs.environment }}
        working-directory: frontend
        env:
          VITE_API_URL: ${{ needs.configure.outputs.api_url }}
          VITE_COGNITO_USER_POOL_ID: ${{ needs.configure.outputs.cognito_user_pool_id }}
          VITE_COGNITO_APP_CLIENT_ID: ${{ needs.configure.outputs.cognito_client_id }}
          VITE_COGNITO_DOMAIN: ${{ needs.configure.outputs.cognito_domain }}
        run: npm run build

      - name: Upload frontend artifact
        uses: actions/upload-artifact@v6
        with:
          name: frontend-dist
          path: frontend/dist
          retention-days: 1
          overwrite: true  # CI job may have uploaded same artifact

  # ============================================
  # Deploy to AWS
  # ============================================

  deploy:
    name: Deploy to ${{ needs.configure.outputs.environment }}
    runs-on: ubuntu-latest
    needs: [configure, generate-version, build-backend, build-frontend, build-scraper]
    # Always run if build jobs succeed, even if build-scraper was skipped
    if: |
      always() &&
      needs.build-backend.result == 'success' &&
      needs.build-frontend.result == 'success' &&
      (needs.build-scraper.result == 'success' || needs.build-scraper.result == 'skipped')
    environment: ${{ needs.configure.outputs.environment }}

    steps:
      - uses: actions/checkout@v6

      - name: Configure AWS credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v5
        with:
          # Select role ARN based on environment (secrets can't be passed via job outputs)
          role-to-assume: ${{ needs.configure.outputs.environment == 'production' && secrets.AWS_DEPLOY_ROLE_ARN || secrets.AWS_STAGING_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Download Lambda artifact
        uses: actions/download-artifact@v7
        with:
          name: lambda-package
          path: .

      - name: Download frontend artifact
        uses: actions/download-artifact@v7
        with:
          name: frontend-dist
          path: frontend-dist

      # ---- Deploy Lambda ----
      - name: Upload Lambda to S3
        run: |
          aws s3 cp lambda-package.zip \
            s3://${{ needs.configure.outputs.s3_frontend_bucket }}/lambda/bluemoxon-api.zip

      - name: Update Lambda function
        run: |
          aws lambda update-function-code \
            --function-name ${{ needs.configure.outputs.lambda_function_name }} \
            --s3-bucket ${{ needs.configure.outputs.s3_frontend_bucket }} \
            --s3-key lambda/bluemoxon-api.zip

      - name: Wait for Lambda update
        run: |
          echo "Waiting for Lambda function to be ready..."
          aws lambda wait function-updated \
            --function-name ${{ needs.configure.outputs.lambda_function_name }}
          echo "Lambda function updated successfully"

      - name: Publish Lambda version
        id: lambda-version
        run: |
          echo "Publishing new Lambda version..."
          VERSION=$(aws lambda publish-version \
            --function-name ${{ needs.configure.outputs.lambda_function_name }} \
            --description "Deployed from commit ${{ github.sha }}" \
            --query 'Version' \
            --output text)

          echo "Published version: $VERSION"
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Update Lambda alias
        run: |
          # Use environment-specific alias name
          if [[ "${{ needs.configure.outputs.environment }}" == "production" ]]; then
            ALIAS_NAME="prod"
          else
            ALIAS_NAME="staging"
          fi
          FUNCTION_NAME="${{ needs.configure.outputs.lambda_function_name }}"
          VERSION="${{ steps.lambda-version.outputs.version }}"

          # Check if alias exists
          if aws lambda get-alias --function-name "$FUNCTION_NAME" --name "$ALIAS_NAME" 2>/dev/null; then
            echo "Updating existing alias '$ALIAS_NAME' to version $VERSION"
            aws lambda update-alias \
              --function-name "$FUNCTION_NAME" \
              --name "$ALIAS_NAME" \
              --function-version "$VERSION"
          else
            echo "Creating alias '$ALIAS_NAME' pointing to version $VERSION"
            aws lambda create-alias \
              --function-name "$FUNCTION_NAME" \
              --name "$ALIAS_NAME" \
              --function-version "$VERSION"
          fi

      - name: Cleanup old Lambda versions
        run: |
          FUNCTION_NAME="${{ needs.configure.outputs.lambda_function_name }}"
          KEEP_VERSIONS=3

          echo "Cleaning up old Lambda versions (keeping last $KEEP_VERSIONS)..."

          # Get all versions except $LATEST, sorted numerically descending
          VERSIONS=$(aws lambda list-versions-by-function \
            --function-name "$FUNCTION_NAME" \
            --query 'Versions[?Version!=`$LATEST`].Version' \
            --output text | tr '\t' '\n' | sort -rn)

          # Skip the first N versions (the ones we want to keep)
          VERSIONS_TO_DELETE=$(echo "$VERSIONS" | tail -n +$((KEEP_VERSIONS + 1)))

          if [ -z "$VERSIONS_TO_DELETE" ]; then
            echo "No old versions to delete"
          else
            for VERSION in $VERSIONS_TO_DELETE; do
              echo "Deleting version $VERSION"
              aws lambda delete-function \
                --function-name "$FUNCTION_NAME" \
                --qualifier "$VERSION" || true
            done
          fi

      # ---- Deploy Analysis Worker Lambda (if configured) ----
      - name: Update Worker Lambda function
        if: needs.configure.outputs.worker_function_name != ''
        run: |
          WORKER_FUNCTION="${{ needs.configure.outputs.worker_function_name }}"
          echo "Deploying worker Lambda: $WORKER_FUNCTION"

          aws lambda update-function-code \
            --function-name "$WORKER_FUNCTION" \
            --s3-bucket ${{ needs.configure.outputs.s3_frontend_bucket }} \
            --s3-key lambda/bluemoxon-api.zip

      - name: Wait for Worker Lambda update
        if: needs.configure.outputs.worker_function_name != ''
        run: |
          WORKER_FUNCTION="${{ needs.configure.outputs.worker_function_name }}"
          echo "Waiting for Worker Lambda to be ready..."
          aws lambda wait function-updated --function-name "$WORKER_FUNCTION"
          echo "Worker Lambda updated successfully"

      - name: Publish Worker Lambda version
        if: needs.configure.outputs.worker_function_name != ''
        id: worker-version
        run: |
          WORKER_FUNCTION="${{ needs.configure.outputs.worker_function_name }}"
          echo "Publishing new Worker Lambda version..."

          VERSION=$(aws lambda publish-version \
            --function-name "$WORKER_FUNCTION" \
            --description "Deployed from commit ${{ github.sha }}" \
            --query 'Version' \
            --output text)

          echo "Published worker version: $VERSION"
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      # ---- Deploy Eval Runbook Worker Lambda (if configured) ----
      - name: Update Eval Runbook Worker Lambda function
        if: needs.configure.outputs.eval_runbook_worker_function_name != ''
        run: |
          EVAL_RUNBOOK_FUNCTION="${{ needs.configure.outputs.eval_runbook_worker_function_name }}"
          echo "Deploying eval runbook worker Lambda: $EVAL_RUNBOOK_FUNCTION"

          aws lambda update-function-code \
            --function-name "$EVAL_RUNBOOK_FUNCTION" \
            --s3-bucket ${{ needs.configure.outputs.s3_frontend_bucket }} \
            --s3-key lambda/bluemoxon-api.zip

      - name: Wait for Eval Runbook Worker Lambda update
        if: needs.configure.outputs.eval_runbook_worker_function_name != ''
        run: |
          EVAL_RUNBOOK_FUNCTION="${{ needs.configure.outputs.eval_runbook_worker_function_name }}"
          echo "Waiting for Eval Runbook Worker Lambda to be ready..."
          aws lambda wait function-updated --function-name "$EVAL_RUNBOOK_FUNCTION"
          echo "Eval Runbook Worker Lambda updated successfully"

      - name: Publish Eval Runbook Worker Lambda version
        if: needs.configure.outputs.eval_runbook_worker_function_name != ''
        id: eval-runbook-version
        run: |
          EVAL_RUNBOOK_FUNCTION="${{ needs.configure.outputs.eval_runbook_worker_function_name }}"
          echo "Publishing new Eval Runbook Worker Lambda version..."

          VERSION=$(aws lambda publish-version \
            --function-name "$EVAL_RUNBOOK_FUNCTION" \
            --description "Deployed from commit ${{ github.sha }}" \
            --query 'Version' \
            --output text)

          echo "Published eval runbook worker version: $VERSION"
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      # ---- Deploy Scraper Lambda (if configured) ----
      - name: Update Scraper Lambda function
        if: needs.configure.outputs.scraper_function_name != '' && needs.build-scraper.result == 'success'
        run: |
          SCRAPER_FUNCTION="${{ needs.configure.outputs.scraper_function_name }}"
          ECR_REPOSITORY="${{ needs.configure.outputs.scraper_ecr_repository }}"
          AWS_ACCOUNT="${{ needs.configure.outputs.aws_account_id }}"
          IMAGE_TAG="${{ needs.generate-version.outputs.version }}"

          IMAGE_URI="${AWS_ACCOUNT}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${ECR_REPOSITORY}:${IMAGE_TAG}"

          echo "Deploying scraper Lambda: $SCRAPER_FUNCTION"
          echo "Image URI: $IMAGE_URI"

          aws lambda update-function-code \
            --function-name "$SCRAPER_FUNCTION" \
            --image-uri "$IMAGE_URI"

      - name: Wait for Scraper Lambda update
        if: needs.configure.outputs.scraper_function_name != '' && needs.build-scraper.result == 'success'
        run: |
          SCRAPER_FUNCTION="${{ needs.configure.outputs.scraper_function_name }}"
          echo "Waiting for Scraper Lambda to be ready..."
          aws lambda wait function-updated --function-name "$SCRAPER_FUNCTION"
          echo "Scraper Lambda updated successfully"

      - name: Publish Scraper Lambda version
        if: needs.configure.outputs.scraper_function_name != '' && needs.build-scraper.result == 'success'
        id: scraper-version
        run: |
          SCRAPER_FUNCTION="${{ needs.configure.outputs.scraper_function_name }}"
          echo "Publishing new Scraper Lambda version..."

          VERSION=$(aws lambda publish-version \
            --function-name "$SCRAPER_FUNCTION" \
            --description "Deployed from commit ${{ github.sha }}" \
            --query 'Version' \
            --output text)

          echo "Published scraper version: $VERSION"
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      # ---- Run Database Migrations ----
      - name: Run database migrations
        run: |
          echo "Running database migrations..."
          API_URL="${{ needs.configure.outputs.api_url }}"

          # Wait for Lambda to be fully available
          sleep 5

          # Call the migrate endpoint (api_url already includes /api/v1)
          response=$(curl -s -w "\n%{http_code}" -X POST "${API_URL}/health/migrate")
          http_code=$(echo "$response" | tail -n1)
          body=$(echo "$response" | sed '$d')

          echo "HTTP Code: $http_code"
          echo "Response:"
          echo "$body" | jq '.' 2>/dev/null || echo "$body"

          if [[ "$http_code" != "200" ]]; then
            echo "ERROR: Migration endpoint returned HTTP $http_code"
            exit 1
          fi

          # Check migration status
          status=$(echo "$body" | jq -r '.status' 2>/dev/null)
          if [[ "$status" == "failed" ]]; then
            echo "ERROR: Migrations failed!"
            echo "$body" | jq '.errors' 2>/dev/null
            exit 1
          fi

          # Log migration results
          prev_version=$(echo "$body" | jq -r '.previous_version // "none"' 2>/dev/null)
          new_version=$(echo "$body" | jq -r '.new_version // "unknown"' 2>/dev/null)
          result_count=$(echo "$body" | jq -r '.results | length' 2>/dev/null)

          echo ""
          echo "✅ Migrations completed successfully!"
          echo "   Previous version: $prev_version"
          echo "   New version: $new_version"
          echo "   Statements executed: $result_count"

      # ---- Deploy Frontend ----
      - name: Sync frontend to S3
        run: |
          aws s3 sync frontend-dist/ s3://${{ needs.configure.outputs.s3_frontend_bucket }}/ \
            --delete \
            --cache-control "max-age=31536000,public" \
            --exclude "index.html" \
            --exclude "*.json"

          # Upload index.html and JSON with no-cache
          aws s3 cp frontend-dist/index.html \
            s3://${{ needs.configure.outputs.s3_frontend_bucket }}/index.html \
            --cache-control "no-cache,no-store,must-revalidate"

          # Upload any JSON config files with no-cache
          if ls frontend-dist/*.json 1> /dev/null 2>&1; then
            for f in frontend-dist/*.json; do
              aws s3 cp "$f" "s3://${{ needs.configure.outputs.s3_frontend_bucket }}/$(basename $f)" \
                --cache-control "no-cache,no-store,must-revalidate"
            done
          fi

      - name: Invalidate CloudFront cache
        run: |
          INVALIDATION_ID=$(aws cloudfront create-invalidation \
            --distribution-id ${{ needs.configure.outputs.cloudfront_distribution_id }} \
            --paths "/*" \
            --query 'Invalidation.Id' \
            --output text)

          echo "CloudFront invalidation started: $INVALIDATION_ID"

          # Wait for invalidation to complete (optional, adds ~1-2 min)
          echo "Waiting for invalidation to complete..."
          aws cloudfront wait invalidation-completed \
            --distribution-id ${{ needs.configure.outputs.cloudfront_distribution_id }} \
            --id $INVALIDATION_ID
          echo "CloudFront invalidation completed"

  # ============================================
  # Smoke Tests
  # ============================================

  smoke-test:
    name: Smoke Tests (${{ needs.configure.outputs.environment }})
    runs-on: ubuntu-latest
    needs: [configure, deploy, generate-version, build-scraper]

    steps:
      - name: Configure AWS credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ needs.configure.outputs.environment == 'production' && secrets.AWS_DEPLOY_ROLE_ARN || secrets.AWS_STAGING_ROLE_ARN }}
          aws-region: us-west-2

      - name: Wait for deployment to propagate
        run: sleep 30

      - name: Set test URLs
        id: urls
        run: |
          ENV="${{ needs.configure.outputs.environment }}"
          if [[ "$ENV" == "production" ]]; then
            echo "api_base=https://api.bluemoxon.com" >> $GITHUB_OUTPUT
            echo "app_url=https://app.bluemoxon.com" >> $GITHUB_OUTPUT
          else
            echo "api_base=https://staging.api.bluemoxon.com" >> $GITHUB_OUTPUT
            echo "app_url=https://staging.app.bluemoxon.com" >> $GITHUB_OUTPUT
          fi

      - name: Test API liveness
        run: |
          echo "Testing API liveness probe..."
          API_BASE="${{ steps.urls.outputs.api_base }}"
          response=$(curl -s -w "\n%{http_code}" "${API_BASE}/health")
          http_code=$(echo "$response" | tail -n1)
          body=$(echo "$response" | sed '$d')

          echo "Response: $body"
          echo "HTTP Code: $http_code"

          if [[ "$http_code" != "200" ]]; then
            echo "Liveness check failed!"
            exit 1
          fi
          echo "API liveness check passed!"

      - name: Validate version and environment
        run: |
          echo "Validating deployed version and environment..."

          API_BASE="${{ steps.urls.outputs.api_base }}"
          EXPECTED_VERSION="${{ needs.generate-version.outputs.version }}"
          EXPECTED_ENV="${{ needs.configure.outputs.environment }}"

          # Get actual version info from API
          response=$(curl -s "${API_BASE}/api/v1/health/version")
          ACTUAL_VERSION=$(echo "$response" | jq -r '.version')
          ACTUAL_ENV=$(echo "$response" | jq -r '.environment')

          echo "Expected version: $EXPECTED_VERSION"
          echo "Actual version:   $ACTUAL_VERSION"
          echo "Expected env:     $EXPECTED_ENV"
          echo "Actual env:       $ACTUAL_ENV"

          # Validate version
          if [[ "$ACTUAL_VERSION" != "$EXPECTED_VERSION" ]]; then
            echo "ERROR: Version mismatch!"
            echo "  Expected: $EXPECTED_VERSION"
            echo "  Got: $ACTUAL_VERSION"
            exit 1
          fi

          # Validate environment
          if [[ "$ACTUAL_ENV" != "$EXPECTED_ENV" ]]; then
            echo "ERROR: Environment mismatch!"
            echo "  Expected: $EXPECTED_ENV"
            echo "  Got: $ACTUAL_ENV"
            exit 1
          fi

          # Also check response headers
          HEADER_VERSION=$(curl -sI "${API_BASE}/health" | grep -i "x-app-version" | cut -d: -f2 | tr -d ' \r')
          HEADER_ENV=$(curl -sI "${API_BASE}/health" | grep -i "x-environment" | cut -d: -f2 | tr -d ' \r')

          echo "Header X-App-Version: $HEADER_VERSION"
          echo "Header X-Environment: $HEADER_ENV"

          if [[ "$HEADER_VERSION" != "$EXPECTED_VERSION" ]]; then
            echo "ERROR: X-App-Version header mismatch!"
            exit 1
          fi

          if [[ "$HEADER_ENV" != "$EXPECTED_ENV" ]]; then
            echo "ERROR: X-Environment header mismatch!"
            exit 1
          fi

          echo "✅ Version and environment validation passed!"

      - name: Test API deep health check
        run: |
          echo "Running deep health check..."
          API_BASE="${{ steps.urls.outputs.api_base }}"
          ENV="${{ needs.configure.outputs.environment }}"
          response=$(curl -s -w "\n%{http_code}" "${API_BASE}/api/v1/health/deep")
          http_code=$(echo "$response" | tail -n1)
          body=$(echo "$response" | sed '$d')

          echo "HTTP Code: $http_code"
          echo "Response:"
          echo "$body" | jq '.' 2>/dev/null || echo "$body"

          if [[ "$http_code" != "200" ]]; then
            echo "Deep health check endpoint failed!"
            exit 1
          fi

          # Check overall status
          status=$(echo "$body" | jq -r '.status' 2>/dev/null)
          if [[ "$status" == "unhealthy" ]]; then
            echo "CRITICAL: System is unhealthy!"
            echo "$body" | jq '.checks' 2>/dev/null
            exit 1
          elif [[ "$status" == "degraded" ]]; then
            echo "WARNING: System is degraded but operational"
            echo "$body" | jq '.checks' 2>/dev/null
            # For staging, degraded is acceptable (no database yet)
            if [[ "$ENV" == "production" ]]; then
              echo "Production should not be degraded - investigate!"
            fi
          fi

          # Verify database is healthy (critical for production)
          db_status=$(echo "$body" | jq -r '.checks.database.status' 2>/dev/null)
          if [[ "$db_status" != "healthy" && "$ENV" == "production" ]]; then
            echo "CRITICAL: Database is not healthy!"
            echo "$body" | jq '.checks.database' 2>/dev/null
            exit 1
          fi

          # Log latency metrics
          db_latency=$(echo "$body" | jq -r '.checks.database.latency_ms' 2>/dev/null)
          total_latency=$(echo "$body" | jq -r '.total_latency_ms' 2>/dev/null)
          echo "Database latency: ${db_latency}ms"
          echo "Total health check latency: ${total_latency}ms"

          echo "Deep health check passed!"

      - name: Test API books endpoint
        run: |
          echo "Testing books API..."
          API_BASE="${{ steps.urls.outputs.api_base }}"
          response=$(curl -s -w "\n%{http_code}" "${API_BASE}/api/v1/books?per_page=1")
          http_code=$(echo "$response" | tail -n1)
          body=$(echo "$response" | sed '$d')

          echo "HTTP Code: $http_code"

          if [[ "$http_code" != "200" ]]; then
            echo "Books API check failed!"
            exit 1
          fi

          # Verify pagination response
          if ! echo "$body" | grep -q '"total"'; then
            echo "Books response missing pagination!"
            exit 1
          fi

          total=$(echo "$body" | jq -r '.total' 2>/dev/null)
          echo "Books API check passed! Found $total books."

      - name: Test API authentication
        run: |
          echo "Testing API authentication (should reject unauthenticated requests)..."
          API_BASE="${{ steps.urls.outputs.api_base }}"

          # Test that POST to books requires auth (should return 401/403)
          http_code=$(curl -s -o /dev/null -w "%{http_code}" \
            -X POST "${API_BASE}/api/v1/books" \
            -H "Content-Type: application/json" \
            -d '{"title":"test"}')

          echo "HTTP Code for unauthenticated POST: $http_code"

          if [[ "$http_code" != "401" && "$http_code" != "403" ]]; then
            echo "ERROR: Expected 401 or 403 for unauthenticated request, got $http_code"
            exit 1
          fi

          echo "Authentication check passed! Unauthenticated requests correctly rejected."

      - name: Test CORS headers
        run: |
          echo "Testing CORS headers..."
          API_BASE="${{ steps.urls.outputs.api_base }}"
          APP_URL="${{ steps.urls.outputs.app_url }}"

          # Make preflight OPTIONS request
          response=$(curl -s -I -X OPTIONS "${API_BASE}/api/v1/books" \
            -H "Origin: ${APP_URL}" \
            -H "Access-Control-Request-Method: GET")

          # Check for CORS headers
          if echo "$response" | grep -qi "access-control-allow-origin"; then
            origin_header=$(echo "$response" | grep -i "access-control-allow-origin" | head -1)
            echo "CORS Origin header: $origin_header"
            echo "CORS headers present!"
          else
            echo "WARNING: CORS headers not found in preflight response"
            echo "This may indicate CORS misconfiguration"
            # Don't fail - CORS might be handled differently
          fi

          # Also test actual request includes CORS headers
          response=$(curl -s -I "${API_BASE}/api/v1/books" \
            -H "Origin: ${APP_URL}")

          if echo "$response" | grep -qi "access-control-allow-origin"; then
            echo "CORS headers present in actual request response"
          fi

          echo "CORS check completed!"

      - name: Test Vue app loads
        run: |
          echo "Testing Vue app..."
          APP_URL="${{ steps.urls.outputs.app_url }}"
          http_code=$(curl -s -o /dev/null -w "%{http_code}" "$APP_URL")

          echo "HTTP Code: $http_code"

          if [[ "$http_code" != "200" ]]; then
            echo "Vue app check failed!"
            exit 1
          fi

          # Check that HTML contains expected Vue app content
          if ! curl -s "$APP_URL" | grep -q "BlueMoxon\|bluemoxon"; then
            echo "Vue app doesn't contain expected content!"
            exit 1
          fi

          echo "Vue app check passed!"

      - name: Validate frontend version and config
        run: |
          echo "Validating frontend version and Cognito config..."
          APP_URL="${{ steps.urls.outputs.app_url }}"
          EXPECTED_VERSION="${{ needs.generate-version.outputs.version }}"

          # Get expected values from configure job (which reads from config files)
          EXPECTED_CLIENT_ID="${{ needs.configure.outputs.cognito_client_id }}"
          EXPECTED_POOL_ID="${{ needs.configure.outputs.cognito_user_pool_id }}"

          # Download frontend HTML to find JS bundle name
          html=$(curl -s "$APP_URL")
          js_file=$(echo "$html" | grep -oE '/assets/index-[a-zA-Z0-9_-]+\.js' | head -1)

          if [[ -z "$js_file" ]]; then
            echo "ERROR: Could not find main JS bundle in HTML!"
            exit 1
          fi

          echo "Found JS bundle: $js_file"

          # Download JS bundle and check for expected version
          # js_file includes leading slash, so no need to add another
          js_content=$(curl -s "${APP_URL}${js_file}")

          # Check version in JS bundle
          if echo "$js_content" | grep -q "$EXPECTED_VERSION"; then
            echo "✅ Frontend version matches: $EXPECTED_VERSION"
          else
            # Try to find what version is actually there
            ACTUAL_VERSION=$(echo "$js_content" | grep -oE '20[0-9]{2}\.[0-9]{2}\.[0-9]{2}-[a-f0-9]{7}' | head -1)
            echo "ERROR: Frontend version mismatch!"
            echo "  Expected: $EXPECTED_VERSION"
            echo "  Found: ${ACTUAL_VERSION:-not found}"
            exit 1
          fi

          # Check Cognito client ID in JS bundle
          if echo "$js_content" | grep -q "$EXPECTED_CLIENT_ID"; then
            echo "✅ Cognito client ID matches: $EXPECTED_CLIENT_ID"
          else
            # Try to find what client ID is actually there
            ACTUAL_CLIENT=$(echo "$js_content" | grep -oE '[0-9a-z]{26}' | head -1)
            echo "ERROR: Cognito client ID mismatch!"
            echo "  Expected: $EXPECTED_CLIENT_ID"
            echo "  Found: ${ACTUAL_CLIENT:-not found}"
            echo "  This usually means CI and deploy workflows have artifact name collision."
            exit 1
          fi

          # Check Cognito pool ID in JS bundle
          if echo "$js_content" | grep -q "$EXPECTED_POOL_ID"; then
            echo "✅ Cognito pool ID matches: $EXPECTED_POOL_ID"
          else
            ACTUAL_POOL=$(echo "$js_content" | grep -oE 'us-west-2_[A-Za-z0-9]+' | head -1)
            echo "ERROR: Cognito pool ID mismatch!"
            echo "  Expected: $EXPECTED_POOL_ID"
            echo "  Found: ${ACTUAL_POOL:-not found}"
            exit 1
          fi

          echo "Frontend configuration validation passed!"

      - name: Test image endpoint (CloudFront CDN)
        run: |
          echo "Testing image CloudFront CDN..."
          API_BASE="${{ steps.urls.outputs.api_base }}"
          ENV="${{ needs.configure.outputs.environment }}"

          # Get first book with images via API
          book_response=$(curl -s "${API_BASE}/api/v1/books?has_images=true&per_page=1")
          total_with_images=$(echo "$book_response" | jq -r '.total' 2>/dev/null)

          echo "Books with images in database: $total_with_images"

          if [[ "$total_with_images" == "0" || "$total_with_images" == "null" ]]; then
            echo "INFO: No books with images found"
            exit 0
          fi

          if echo "$book_response" | grep -q '"primary_image_url"'; then
            image_url=$(echo "$book_response" | jq -r '.items[0].primary_image_url' 2>/dev/null)

            echo "Primary image URL: $image_url"

            # Check if URL is relative (starts with /) - means no CDN configured or images not synced
            if [[ "$image_url" == /* ]]; then
              if [[ "$ENV" == "staging" ]]; then
                echo "INFO: Staging returns relative image URLs (no CDN images synced yet)"
                echo "This is expected - staging uses prod database but separate S3 bucket"
                echo "Image CDN test skipped for staging"
                exit 0
              else
                echo "WARNING: Production returning relative image URLs instead of CDN URLs"
                # Continue to test via API path
                image_url="${API_BASE}${image_url}"
              fi
            fi

            if [[ -n "$image_url" && "$image_url" != "null" ]]; then
              echo "Testing full image URL: $image_url"

              # Get headers and body info
              response=$(curl -sI -L "$image_url")
              http_code=$(echo "$response" | grep -i "^HTTP" | tail -1 | awk '{print $2}')
              content_type=$(echo "$response" | grep -i "^content-type:" | tail -1 | awk '{print $2}' | tr -d '\r')
              content_length=$(echo "$response" | grep -i "^content-length:" | tail -1 | awk '{print $2}' | tr -d '\r')

              echo "HTTP Code: $http_code"
              echo "Content-Type: $content_type"
              echo "Content-Length: $content_length"

              # Verify HTTP 200
              if [[ "$http_code" != "200" ]]; then
                echo "ERROR: Image returned HTTP $http_code, expected 200"
                exit 1
              fi

              # Verify content-type is an image (not text/html error page)
              if [[ ! "$content_type" =~ ^image/ ]]; then
                echo "ERROR: Image returned content-type '$content_type', expected image/*"
                echo "This usually means CloudFront is returning an error page!"
                exit 1
              fi

              # Verify content-length is reasonable (> 1KB, not a tiny error page)
              if [[ "$content_length" -lt 1000 ]]; then
                echo "ERROR: Image content-length $content_length is suspiciously small"
                exit 1
              fi

              echo "Image endpoint working! Content verified as $content_type ($content_length bytes)"
            else
              echo "INFO: No image URL found in response (book may not have primary image)"
            fi
          else
            echo "INFO: No primary_image_url field in response"
          fi

      - name: Test Scraper Lambda version
        if: needs.configure.outputs.scraper_function_name != '' && needs.build-scraper.result == 'success'
        run: |
          echo "Testing Scraper Lambda version..."
          SCRAPER_FUNCTION="${{ needs.configure.outputs.scraper_function_name }}"
          EXPECTED_VERSION="${{ needs.generate-version.outputs.version }}"

          # Invoke Lambda with version check payload
          response=$(aws lambda invoke \
            --function-name "$SCRAPER_FUNCTION" \
            --payload '{"version": true}' \
            --cli-binary-format raw-in-base64-out \
            /tmp/scraper-response.json \
            --query 'StatusCode' \
            --output text)

          echo "Lambda invoke status: $response"

          if [[ "$response" != "200" ]]; then
            echo "ERROR: Scraper Lambda invocation failed with status $response"
            exit 1
          fi

          # Parse response body
          body=$(cat /tmp/scraper-response.json)
          echo "Response body: $body"

          # Extract version from response
          actual_version=$(echo "$body" | jq -r '.body' | jq -r '.version')
          echo "Expected version: $EXPECTED_VERSION"
          echo "Actual version: $actual_version"

          if [[ "$actual_version" != "$EXPECTED_VERSION" ]]; then
            echo "ERROR: Scraper version mismatch!"
            echo "  Expected: $EXPECTED_VERSION"
            echo "  Got: $actual_version"
            exit 1
          fi

          echo "Scraper Lambda version check passed!"

      - name: Test Analysis Worker Lambda configuration
        if: needs.configure.outputs.worker_function_name != ''
        run: |
          echo "Verifying Analysis Worker Lambda configuration..."
          WORKER_FUNCTION="${{ needs.configure.outputs.worker_function_name }}"
          EXPECTED_VERSION="${{ needs.generate-version.outputs.version }}"

          # Get function configuration
          CONFIG=$(aws lambda get-function-configuration \
            --function-name "$WORKER_FUNCTION" \
            --query '{Runtime: Runtime, Handler: Handler, State: State, LastUpdateStatus: LastUpdateStatus}' \
            --output json)

          echo "Worker Lambda configuration:"
          echo "$CONFIG" | jq '.'

          # Verify function is active and up to date
          STATE=$(echo "$CONFIG" | jq -r '.State')
          UPDATE_STATUS=$(echo "$CONFIG" | jq -r '.LastUpdateStatus')

          if [[ "$STATE" != "Active" ]]; then
            echo "ERROR: Worker Lambda state is $STATE, expected Active"
            exit 1
          fi

          if [[ "$UPDATE_STATUS" != "Successful" ]]; then
            echo "ERROR: Worker Lambda last update status is $UPDATE_STATUS, expected Successful"
            exit 1
          fi

          echo "Analysis Worker Lambda configuration verified!"

      - name: Test Eval Runbook Worker Lambda configuration
        if: needs.configure.outputs.eval_runbook_worker_function_name != ''
        run: |
          echo "Verifying Eval Runbook Worker Lambda configuration..."
          EVAL_RUNBOOK_FUNCTION="${{ needs.configure.outputs.eval_runbook_worker_function_name }}"

          # Get function configuration
          CONFIG=$(aws lambda get-function-configuration \
            --function-name "$EVAL_RUNBOOK_FUNCTION" \
            --query '{Runtime: Runtime, Handler: Handler, State: State, LastUpdateStatus: LastUpdateStatus}' \
            --output json)

          echo "Eval Runbook Worker Lambda configuration:"
          echo "$CONFIG" | jq '.'

          # Verify function is active and up to date
          STATE=$(echo "$CONFIG" | jq -r '.State')
          UPDATE_STATUS=$(echo "$CONFIG" | jq -r '.LastUpdateStatus')

          if [[ "$STATE" != "Active" ]]; then
            echo "ERROR: Eval Runbook Worker Lambda state is $STATE, expected Active"
            exit 1
          fi

          if [[ "$UPDATE_STATUS" != "Successful" ]]; then
            echo "ERROR: Eval Runbook Worker Lambda last update status is $UPDATE_STATUS, expected Successful"
            exit 1
          fi

          echo "Eval Runbook Worker Lambda configuration verified!"

      - name: Deployment summary
        run: |
          ENV="${{ needs.configure.outputs.environment }}"
          APP_URL="${{ steps.urls.outputs.app_url }}"
          API_BASE="${{ steps.urls.outputs.api_base }}"
          VERSION="${{ needs.generate-version.outputs.version }}"
          DRIFT_STATUS="${{ needs.configure.outputs.drift_detected }}"
          SCRAPER_FUNCTION="${{ needs.configure.outputs.scraper_function_name }}"
          WORKER_FUNCTION="${{ needs.configure.outputs.worker_function_name }}"
          EVAL_RUNBOOK_FUNCTION="${{ needs.configure.outputs.eval_runbook_worker_function_name }}"

          echo "========================================"
          echo "Deployment to $ENV completed successfully!"
          echo "========================================"
          echo ""
          echo "Version: $VERSION"
          if [[ "$DRIFT_STATUS" == "true" ]]; then
            echo "Drift: ⚠️  DETECTED (warn-only)"
          elif [[ "$DRIFT_STATUS" == "error" ]]; then
            echo "Drift: ❓ Check failed"
          else
            echo "Drift: ✅ None detected"
          fi
          echo ""
          echo "URLs:"
          echo "  App: $APP_URL"
          echo "  API: $API_BASE"
          echo ""
          echo "Lambdas:"
          echo "  API: ${{ needs.configure.outputs.lambda_function_name }}"
          if [[ -n "$WORKER_FUNCTION" ]]; then
            echo "  Analysis Worker: $WORKER_FUNCTION"
          fi
          if [[ -n "$EVAL_RUNBOOK_FUNCTION" ]]; then
            echo "  Eval Runbook Worker: $EVAL_RUNBOOK_FUNCTION"
          fi
          if [[ -n "$SCRAPER_FUNCTION" ]]; then
            echo "  Scraper: $SCRAPER_FUNCTION"
          fi
          echo ""
          echo "Deployed at: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          echo "Commit: ${{ github.sha }}"
          echo "========================================"

  # ============================================
  # Create Release Tag
  # ============================================

  create-release:
    name: Create Release Tag
    runs-on: ubuntu-latest
    needs: [configure, smoke-test]
    # Only create release tags for production deployments
    if: needs.configure.outputs.environment == 'production'

    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 0  # Full history for tagging

      - name: Create release tag
        run: |
          # Generate version tag: v{date}-{short-sha}
          VERSION="v$(date -u '+%Y.%m.%d')-$(echo ${{ github.sha }} | head -c 7)"

          echo "Creating release tag: $VERSION"

          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Create annotated tag
          git tag -a "$VERSION" -m "Release $VERSION

          Deployed at: $(date -u '+%Y-%m-%d %H:%M:%S UTC')
          Commit: ${{ github.sha }}

          URLs:
          - Collection App: https://app.bluemoxon.com
          - Landing/Docs: https://www.bluemoxon.com
          - API: https://api.bluemoxon.com"

          # Push tag
          git push origin "$VERSION"

          echo "Release tag created: $VERSION"
          echo "View at: https://github.com/${{ github.repository }}/releases/tag/$VERSION"
