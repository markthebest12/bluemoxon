# Phase 2.0: Quality Cleanup Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Clean up technical debt from Phase 1 before adding new features, establishing the pattern for handling deferred work.

**Architecture:** 7 parallel worktrees handling 25 issues grouped by module/concern. Each worktree is independently mergeable to staging.

**Tech Stack:** Python/FastAPI (backend), Vue 3/TypeScript (frontend), Vitest (frontend tests), pytest (backend tests)

---

## Worktree Overview

| Worktree | Branch | Issues | Estimated Tasks |
|----------|--------|--------|-----------------|
| 1. Backend API | `feat/2.0/backend-api` | #1357, #1358, #1363, #1367, #1372, #1385, #1393 | 14 |
| 2. NetworkGraph | `feat/2.0/network-perf` | #1364, #1374 | 4 |
| 3. Detail Panels | `feat/2.0/detail-panels` | #1386, #1389, #1391 | 6 |
| 4. Timeline/URL | `feat/2.0/timeline-url` | #1369, #1373 | 4 |
| 5. Types/Constants | `feat/2.0/types-constants` | #1366, #1387 | 4 |
| 6. Frontend Misc | `feat/2.0/frontend-misc` | #1359, #1365, #1368, #1375, #1388 | 10 |
| 7. Tests | `feat/2.0/tests` | #1370, #1380, #1382, #1390 | 8 |

---

## Worktree 1: Backend API

**Branch:** `feat/2.0/backend-api`

**Files:**
- `backend/app/services/social_circles.py`
- `backend/app/api/v1/social_circles.py`
- `backend/app/api/v1/health.py`
- `backend/app/api/v1/books.py`
- `backend/app/schemas/social_circles.py`
- `backend/tests/api/v1/test_social_circles.py`

### Task 1.1: Fix non-deterministic shared_publisher truncation (#1363)

**Step 1:** Write failing test

```python
# backend/tests/api/v1/test_social_circles.py

def test_shared_publisher_truncation_is_deterministic(db_session, create_book):
    """When >20 authors share a publisher, truncation should be deterministic."""
    # Create publisher with 25 authors
    from app.models import Author, Publisher

    publisher = Publisher(name="Test Publisher")
    db_session.add(publisher)
    db_session.flush()

    authors = []
    for i in range(25):
        author = Author(name=f"Author {i}")
        db_session.add(author)
        authors.append(author)
    db_session.flush()

    # Create books with varying counts per author
    for i, author in enumerate(authors):
        # Author 0 gets 5 books, Author 1 gets 4, etc.
        book_count = max(1, 5 - (i // 5))
        for j in range(book_count):
            create_book(author_id=author.id, publisher_id=publisher.id, status="ON_HAND")

    # Build graph twice
    from app.services.social_circles import build_social_circles_graph
    result1 = build_social_circles_graph(db_session)
    result2 = build_social_circles_graph(db_session)

    # Extract shared_publisher edges
    edges1 = [e for e in result1.edges if e.type == "shared_publisher"]
    edges2 = [e for e in result2.edges if e.type == "shared_publisher"]

    # Should be identical (deterministic)
    assert sorted(e.id for e in edges1) == sorted(e.id for e in edges2)

    # Most prolific authors should be included
    # Authors 0-4 each have 5 books, should be prioritized
    included_author_ids = set()
    for edge in edges1:
        if edge.source.startswith("author:"):
            included_author_ids.add(int(edge.source.split(":")[1]))
        if edge.target.startswith("author:"):
            included_author_ids.add(int(edge.target.split(":")[1]))

    # First 5 authors (most prolific) should be included
    for author in authors[:5]:
        assert author.id in included_author_ids
```

**Step 2:** Run test to verify it fails

```bash
cd backend
poetry run pytest tests/api/v1/test_social_circles.py::test_shared_publisher_truncation_is_deterministic -v
```

Expected: FAIL (non-deterministic ordering)

**Step 3:** Implement fix in `social_circles.py:204-206`

Change from:
```python
if len(author_list) > MAX_AUTHORS_PER_PUBLISHER:
    author_list = author_list[:MAX_AUTHORS_PER_PUBLISHER]
```

To:
```python
if len(author_list) > MAX_AUTHORS_PER_PUBLISHER:
    # Sort by book count descending for deterministic, meaningful truncation
    author_list = sorted(
        author_list,
        key=lambda a: len(author_books[a]),
        reverse=True
    )[:MAX_AUTHORS_PER_PUBLISHER]
```

**Step 4:** Run test to verify it passes

```bash
poetry run pytest tests/api/v1/test_social_circles.py::test_shared_publisher_truncation_is_deterministic -v
```

**Step 5:** Run linting

```bash
poetry run ruff check backend/app/services/social_circles.py
poetry run ruff format --check backend/app/services/social_circles.py
```

**Step 6:** Commit

```bash
git add backend/app/services/social_circles.py backend/tests/api/v1/test_social_circles.py
git commit -m "fix(social-circles): Make shared_publisher truncation deterministic

Sort authors by book count before truncating to MAX_AUTHORS_PER_PUBLISHER.
This ensures:
1. Deterministic results across runs
2. Most prolific authors are prioritized

Closes #1363"
```

---

### Task 1.2: Make MAX_BOOKS configurable via query param (#1367)

**Step 1:** Write failing test

```python
# backend/tests/api/v1/test_social_circles.py

def test_max_books_query_parameter(client, db_session, create_book):
    """max_books query parameter should limit the number of books processed."""
    # Create 150 books
    for i in range(150):
        create_book(title=f"Book {i}", status="ON_HAND")

    # Request with max_books=100
    response = client.get("/api/v1/social-circles/?max_books=100")
    assert response.status_code == 200
    data = response.json()

    # Should process at most 100 books
    assert data["meta"]["total_books"] <= 100


def test_max_books_validation(client):
    """max_books should be validated within reasonable bounds."""
    # Too small
    response = client.get("/api/v1/social-circles/?max_books=50")
    assert response.status_code == 422  # Validation error

    # Too large
    response = client.get("/api/v1/social-circles/?max_books=20000")
    assert response.status_code == 422
```

**Step 2:** Run tests to verify they fail

```bash
poetry run pytest tests/api/v1/test_social_circles.py::test_max_books_query_parameter -v
poetry run pytest tests/api/v1/test_social_circles.py::test_max_books_validation -v
```

**Step 3:** Add query parameter to endpoint

```python
# backend/app/api/v1/social_circles.py

@router.get(
    "/",
    response_model=SocialCirclesResponse,
    summary="Get social circles network graph",
    # ... existing docstring
)
def get_social_circles(
    include_binders: bool = Query(
        True,
        description="Include binder nodes and edges in the graph",
    ),
    min_book_count: int = Query(
        1,
        ge=1,
        le=100,
        description="Minimum books for an entity to be included (max 100)",
    ),
    max_books: int = Query(
        5000,
        ge=100,
        le=10000,
        description="Maximum books to process (100-10000, default 5000)",
    ),
    era: list[Era] | None = Query(
        None,
        description="Filter nodes by historical era(s)",
    ),
    db: Session = Depends(get_db),
    _user_info=Depends(require_viewer),
) -> SocialCirclesResponse:
    """Get the social circles network graph."""
    return build_social_circles_graph(
        db=db,
        include_binders=include_binders,
        min_book_count=min_book_count,
        max_books=max_books,
        era_filter=era,
    )
```

**Step 4:** Update service function signature

```python
# backend/app/services/social_circles.py

def build_social_circles_graph(
    db: Session,
    include_binders: bool = True,
    min_book_count: int = 1,
    max_books: int = 5000,  # Add parameter with default
    era_filter: list[Era] | None = None,
) -> SocialCirclesResponse:
```

And update line 67:
```python
books_query = db.query(Book).filter(Book.status.in_(OWNED_STATUSES)).limit(max_books)
```

And remove the hardcoded `MAX_BOOKS = 5000` constant (line 66).

**Step 5:** Run tests

```bash
poetry run pytest tests/api/v1/test_social_circles.py -v -k "max_books"
```

**Step 6:** Run linting and commit

```bash
poetry run ruff check backend/
poetry run ruff format --check backend/
git add backend/app/api/v1/social_circles.py backend/app/services/social_circles.py backend/tests/
git commit -m "feat(social-circles): Make MAX_BOOKS limit configurable via query param

Add max_books query parameter (100-10000, default 5000) to allow:
- Mobile clients to request smaller datasets
- Data export to request larger datasets

Closes #1367"
```

---

### Task 1.3: Limit book_ids in API response (#1372)

**Step 1:** Write test

```python
# backend/tests/api/v1/test_social_circles.py

def test_book_ids_limited_per_node(client, db_session, create_book):
    """Node book_ids should be limited to prevent response bloat."""
    from app.models import Author

    author = Author(name="Prolific Author")
    db_session.add(author)
    db_session.flush()

    # Create 50 books for this author
    for i in range(50):
        create_book(author_id=author.id, status="ON_HAND")

    response = client.get("/api/v1/social-circles/")
    assert response.status_code == 200
    data = response.json()

    # Find author node
    author_node = next((n for n in data["nodes"] if n["entity_id"] == author.id), None)
    assert author_node is not None

    # book_ids should be limited (e.g., to 10)
    assert len(author_node["book_ids"]) <= 10

    # But book_count should reflect actual count
    assert author_node["book_count"] == 50
```

**Step 2:** Run test to verify it fails

```bash
poetry run pytest tests/api/v1/test_social_circles.py::test_book_ids_limited_per_node -v
```

**Step 3:** Update service to limit book_ids

```python
# backend/app/services/social_circles.py

MAX_BOOK_IDS_PER_NODE = 10  # Add constant near top

# In author node creation (around line 124):
nodes[node_id] = SocialCircleNode(
    # ...
    book_count=len(book_ids),
    book_ids=book_ids[:MAX_BOOK_IDS_PER_NODE],  # Limit for response size
)

# Similarly for publisher nodes (around line 143):
book_ids=list(book_ids_set)[:MAX_BOOK_IDS_PER_NODE],

# And binder nodes (around line 163):
book_ids=list(book_ids_set)[:MAX_BOOK_IDS_PER_NODE],
```

**Step 4:** Run test and lint

```bash
poetry run pytest tests/api/v1/test_social_circles.py::test_book_ids_limited_per_node -v
poetry run ruff check backend/
```

**Step 5:** Commit

```bash
git add backend/app/services/social_circles.py backend/tests/
git commit -m "perf(social-circles): Limit book_ids to 10 per node

Frontend only uses first 10 book_ids for display. Limiting reduces
JSON response size significantly for prolific authors.

book_count still reflects actual total.

Closes #1372"
```

---

### Task 1.4: Add truncation indicator for books API (#1385)

**Step 1:** Locate the truncation code in books.py

```python
# backend/app/api/v1/books.py - around line 414-415
if len(id_list) > 100:
    id_list = id_list[:100]
```

**Step 2:** Write test

```python
# backend/tests/api/v1/test_books.py

def test_ids_parameter_truncation_indicator(client, create_book):
    """When IDs exceed limit, response should include truncated flag."""
    # Create 5 books
    book_ids = [create_book(title=f"Book {i}").id for i in range(5)]

    # Request with more than 100 IDs (simulate with repeated IDs)
    fake_ids = ",".join([str(book_ids[0])] * 150)
    response = client.get(f"/api/v1/books?ids={fake_ids}")

    assert response.status_code == 200
    data = response.json()

    # Should indicate truncation
    assert data.get("ids_truncated") == True
    assert data.get("ids_requested") == 150
    assert data.get("ids_processed") == 100
```

**Step 3:** Implement truncation indicator

Find the IDs handling in books.py and update:

```python
# Track if truncated
ids_truncated = False
ids_requested = len(id_list)

if len(id_list) > 100:
    id_list = id_list[:100]
    ids_truncated = True

# ... later in response ...
return {
    "items": books,
    "total": len(books),
    "ids_truncated": ids_truncated,
    "ids_requested": ids_requested,
    "ids_processed": len(id_list),
}
```

**Step 4:** Run tests and lint

```bash
poetry run pytest tests/api/v1/test_books.py::test_ids_parameter_truncation_indicator -v
poetry run ruff check backend/app/api/v1/books.py
```

**Step 5:** Commit

```bash
git add backend/app/api/v1/books.py backend/tests/
git commit -m "fix(api): Add truncation indicator when IDs parameter exceeds limit

Response now includes:
- ids_truncated: boolean
- ids_requested: original count
- ids_processed: actual count used

Helps frontend detect when some IDs were silently dropped.

Closes #1385"
```

---

### Task 1.5: Add /social-circles/health endpoint (#1393)

**Step 1:** Write test

```python
# backend/tests/api/v1/test_social_circles.py

def test_social_circles_health_endpoint(client, db_session, create_book):
    """Health endpoint should validate social circles data and performance."""
    # Create some test data
    create_book(status="ON_HAND")

    response = client.get("/api/v1/social-circles/health")
    assert response.status_code == 200

    data = response.json()
    assert data["status"] in ["healthy", "degraded", "unhealthy"]
    assert "latency_ms" in data
    assert "checks" in data
    assert "node_counts" in data["checks"]
    assert "edge_counts" in data["checks"]
    assert "query_performance" in data["checks"]
```

**Step 2:** Run test to verify it fails (404)

```bash
poetry run pytest tests/api/v1/test_social_circles.py::test_social_circles_health_endpoint -v
```

**Step 3:** Implement health endpoint

```python
# backend/app/api/v1/social_circles.py

import time
from app.schemas.social_circles import NodeType, ConnectionType

@router.get(
    "/health",
    summary="Social circles health check",
    description="Validates data integrity and query performance for social circles.",
)
def social_circles_health(
    db: Session = Depends(get_db),
    _user_info=Depends(require_viewer),
):
    """Deep health check for social circles feature."""
    start = time.monotonic()

    try:
        # Build graph to measure performance
        result = build_social_circles_graph(db, max_books=1000)
        build_time = (time.monotonic() - start) * 1000

        # Count nodes by type
        node_counts = {
            "authors": sum(1 for n in result.nodes if n.type == NodeType.author),
            "publishers": sum(1 for n in result.nodes if n.type == NodeType.publisher),
            "binders": sum(1 for n in result.nodes if n.type == NodeType.binder),
        }

        # Count edges by type
        edge_counts = {
            "publisher": sum(1 for e in result.edges if e.type == ConnectionType.publisher),
            "shared_publisher": sum(1 for e in result.edges if e.type == ConnectionType.shared_publisher),
            "binder": sum(1 for e in result.edges if e.type == ConnectionType.binder),
        }

        # Determine health status
        perf_healthy = build_time < 500  # Under 500ms threshold
        data_healthy = node_counts["authors"] > 0 or node_counts["publishers"] > 0

        if perf_healthy and data_healthy:
            status = "healthy"
        elif data_healthy:
            status = "degraded"
        else:
            status = "unhealthy"

        return {
            "status": status,
            "latency_ms": round(build_time, 2),
            "checks": {
                "node_counts": {
                    "status": "healthy" if data_healthy else "unhealthy",
                    **node_counts,
                },
                "edge_counts": {
                    "status": "healthy",
                    **edge_counts,
                },
                "query_performance": {
                    "status": "healthy" if perf_healthy else "degraded",
                    "build_time_ms": round(build_time, 2),
                    "threshold_ms": 500,
                },
            },
        }
    except Exception as e:
        return {
            "status": "unhealthy",
            "error": str(e),
            "latency_ms": round((time.monotonic() - start) * 1000, 2),
        }
```

**Step 4:** Run tests and lint

```bash
poetry run pytest tests/api/v1/test_social_circles.py::test_social_circles_health_endpoint -v
poetry run ruff check backend/app/api/v1/social_circles.py
```

**Step 5:** Commit

```bash
git add backend/app/api/v1/social_circles.py backend/tests/
git commit -m "feat(social-circles): Add /social-circles/health endpoint

Validates:
- Node counts by type (authors, publishers, binders)
- Edge counts by type
- Query performance (<500ms threshold)

Closes #1393"
```

---

### Task 1.6: Make date_range fallback configurable (#1358)

**Step 1:** Add constant for default date range

```python
# backend/app/services/social_circles.py - near top

# Default date range for Victorian collection when no node years available
DEFAULT_DATE_RANGE = (1800, 1900)
```

**Step 2:** Update the date_range calculation (line 274)

```python
date_range = (
    min(years) if years else DEFAULT_DATE_RANGE[0],
    max(years) if years else DEFAULT_DATE_RANGE[1],
)
```

**Step 3:** Add docstring explaining the constant

```python
# Default date range for Victorian collection when no node years available.
# These values are reasonable defaults for a Victorian book collection.
# Could be moved to settings if configurability is needed.
DEFAULT_DATE_RANGE = (1800, 1900)
```

**Step 4:** Lint and commit

```bash
poetry run ruff check backend/app/services/social_circles.py
git add backend/app/services/social_circles.py
git commit -m "refactor(social-circles): Extract date_range fallback to constant

Move hardcoded 1800-1900 fallback to DEFAULT_DATE_RANGE constant.
Documents the intentional default for Victorian collections.

Closes #1358"
```

---

### Task 1.7: Review health.py migrate transaction handling (#1357)

**Step 1:** Review current code

The `/health/migrate` endpoint (lines 1131-1225) does have transaction handling:
- `db.commit()` at line 1207
- Error handling that returns early on commit failure

**Step 2:** Identify the issue

The issue is that individual migration steps don't have rollback capability. If step 15 fails after steps 1-14 succeed, we can't roll back.

However, this is acceptable because:
1. Migrations use `IF NOT EXISTS` so are idempotent
2. Each migration is independent
3. The endpoint is only called by admins

**Step 3:** Add documentation and minor improvement

```python
# backend/app/api/v1/health.py - update docstring

@router.post(
    "/migrate",
    summary="Run database migrations",
    description="""
Run pending database migrations. This endpoint allows running migrations
from the Lambda which has VPC access to Aurora.

**Transaction Handling:**
- All migrations run within a single transaction
- If any migration fails, remaining migrations are skipped
- Commit happens at the end if all succeed
- Migrations are idempotent (IF NOT EXISTS) so safe to re-run

**Note:** Individual migration failures don't roll back previous steps,
but since migrations are idempotent, re-running is safe.
    """,
    # ... rest of decorator
)
```

**Step 4:** Commit documentation update

```bash
git add backend/app/api/v1/health.py
git commit -m "docs(health): Document transaction handling in migrate endpoint

Clarifies:
- All migrations run in single transaction
- Commit at end on success
- Idempotent migrations make re-running safe

Closes #1357"
```

---

## Worktree 2: NetworkGraph Performance

**Branch:** `feat/2.0/network-perf`

**Files:**
- `frontend/src/components/socialcircles/NetworkGraph.vue`
- `frontend/src/components/socialcircles/__tests__/NetworkGraph.test.ts`

### Task 2.1: Optimize O(n log n) element ID comparison (#1364)

**Step 1:** Write test

```typescript
// frontend/src/components/socialcircles/__tests__/NetworkGraph.test.ts

describe("element change detection", () => {
  it("should detect element changes efficiently without sorting", async () => {
    // This test verifies the optimization doesn't break functionality
    const wrapper = mount(NetworkGraph, {
      props: {
        elements: [
          { data: { id: "node1" } },
          { data: { id: "node2" } },
        ],
      },
    });

    // Initial render
    await flushPromises();

    // Update with same elements in different order (should detect no change)
    await wrapper.setProps({
      elements: [
        { data: { id: "node2" } },
        { data: { id: "node1" } },
      ],
    });

    // Cytoscape should NOT re-layout (same element IDs)
    // This is implicitly tested by the watch not triggering re-layout
  });
});
```

**Step 2:** Update NetworkGraph.vue lines 212-214

Change from:
```typescript
const newIds = newElements.map((e) => e.data?.id || "").sort();
const idsChanged =
  newIds.length !== lastElementIds.length || newIds.some((id, i) => id !== lastElementIds[i]);
```

To:
```typescript
// Use Set for O(n) comparison instead of O(n log n) sorting
const newIdSet = new Set(newElements.map((e) => e.data?.id || ""));
const idsChanged =
  newIdSet.size !== lastElementIds.size ||
  [...lastElementIds].some((id) => !newIdSet.has(id));
```

Also update line 203 and 218:
```typescript
// Track element IDs to avoid unnecessary re-layouts
let lastElementIds = new Set<string>();

// ...in the watch...
lastElementIds = newIdSet;
```

**Step 3:** Run tests

```bash
npm run --prefix frontend test -- --run NetworkGraph
```

**Step 4:** Lint and commit

```bash
npm run --prefix frontend lint
git add frontend/src/components/socialcircles/NetworkGraph.vue
git commit -m "perf(social-circles): Use Set for O(n) element ID comparison

Replace sorted array comparison with Set-based lookup.
Reduces complexity from O(n log n) to O(n) for large graphs.

Closes #1364"
```

---

### Task 2.2: Remove deep watch on elements array (#1374)

**Step 1:** Understand current code

Line 226 has `{ deep: true }` on the elements watch. The code already computes `idsChanged` to check for actual changes, so the deep watch is redundant overhead.

**Step 2:** Remove deep: true

Change line 226 from:
```typescript
{ deep: true }
```

To:
```typescript
{ flush: 'post' }
```

**Step 3:** Run tests to verify no regression

```bash
npm run --prefix frontend test -- --run NetworkGraph
```

**Step 4:** Lint and commit

```bash
npm run --prefix frontend lint
git add frontend/src/components/socialcircles/NetworkGraph.vue
git commit -m "perf(social-circles): Remove deep watch on elements array

The watch already computes idsChanged to detect actual changes.
Deep watching thousands of elements is unnecessary overhead.

Use flush: 'post' to ensure DOM updates complete before layout.

Closes #1374"
```

---

## Worktree 3: Detail Panels

**Branch:** `feat/2.0/detail-panels`

### Task 3.1: Consolidate ESC key listeners (#1386)

**Step 1:** Identify the duplicate code

- `NodeFloatingCard.vue` lines 130-134, 157-162
- `EdgeSidebar.vue` lines 177-181, 203-208

Both add `window.addEventListener('keydown')` for ESC handling.

**Step 2:** Create shared composable

```typescript
// frontend/src/composables/socialcircles/useEscapeKey.ts

import { onMounted, onUnmounted } from "vue";

export function useEscapeKey(onEscape: () => void) {
  function handleKeydown(event: KeyboardEvent) {
    if (event.key === "Escape") {
      onEscape();
    }
  }

  onMounted(() => {
    window.addEventListener("keydown", handleKeydown);
  });

  onUnmounted(() => {
    window.removeEventListener("keydown", handleKeydown);
  });
}
```

**Step 3:** Update NodeFloatingCard.vue

Remove lines 130-134 and 157-162, add:
```typescript
import { useEscapeKey } from "@/composables/socialcircles/useEscapeKey";

// In setup, replace manual listener with:
useEscapeKey(() => emit("close"));
```

**Step 4:** Update EdgeSidebar.vue similarly

**Step 5:** Write test for composable

```typescript
// frontend/src/composables/socialcircles/__tests__/useEscapeKey.test.ts

import { mount } from "@vue/test-utils";
import { defineComponent } from "vue";
import { useEscapeKey } from "../useEscapeKey";

describe("useEscapeKey", () => {
  it("should call callback when Escape is pressed", async () => {
    const callback = vi.fn();
    const TestComponent = defineComponent({
      setup() {
        useEscapeKey(callback);
        return {};
      },
      template: "<div />",
    });

    mount(TestComponent);

    window.dispatchEvent(new KeyboardEvent("keydown", { key: "Escape" }));
    expect(callback).toHaveBeenCalledTimes(1);
  });

  it("should not call callback for other keys", async () => {
    const callback = vi.fn();
    const TestComponent = defineComponent({
      setup() {
        useEscapeKey(callback);
        return {};
      },
      template: "<div />",
    });

    mount(TestComponent);

    window.dispatchEvent(new KeyboardEvent("keydown", { key: "Enter" }));
    expect(callback).not.toHaveBeenCalled();
  });
});
```

**Step 6:** Run tests and commit

```bash
npm run --prefix frontend test -- --run useEscapeKey
npm run --prefix frontend lint
git add frontend/src/composables/socialcircles/
git add frontend/src/components/socialcircles/NodeFloatingCard.vue
git add frontend/src/components/socialcircles/EdgeSidebar.vue
git commit -m "refactor(social-circles): Consolidate ESC key listeners

Extract shared useEscapeKey composable used by both
NodeFloatingCard and EdgeSidebar.

Reduces duplicate code and ensures consistent behavior.

Closes #1386"
```

---

### Task 3.2: Replace ternary chain with type label map (#1389)

**Step 1:** Locate the ternary in EdgeSidebar.vue lines 326-330

```vue
{{
  targetNode.type === "publisher"
    ? "Publisher"
    : targetNode.type === "binder"
      ? "Bindery"
      : targetNode.type
}}
```

**Step 2:** Add constant for type labels

```typescript
// Add near top of script section
const TYPE_LABELS: Record<string, string> = {
  author: "Author",
  publisher: "Publisher",
  binder: "Bindery",
};

// Or import from formatters if we add it there
```

**Step 3:** Replace ternary with map lookup

```vue
View {{ TYPE_LABELS[targetNode.type] || targetNode.type }}
```

Do the same for lines 320-321 (sourceNode).

**Step 4:** Run tests and commit

```bash
npm run --prefix frontend test -- --run EdgeSidebar
npm run --prefix frontend lint
git add frontend/src/components/socialcircles/EdgeSidebar.vue
git commit -m "refactor(social-circles): Replace ternary chain with type label map

Use TYPE_LABELS constant for entity type display.
More maintainable if new types are added.

Closes #1389"
```

---

### Task 3.3: Hide View Full Profile button (#1391)

**Step 1:** Update NodeFloatingCard.vue footer

Change the footer button to be disabled with a tooltip:

```vue
<!-- Footer -->
<footer class="node-floating-card__footer">
  <button
    class="node-floating-card__profile-button node-floating-card__profile-button--disabled"
    disabled
    title="Entity profiles coming in a future update"
  >
    View Full Profile
    <span class="node-floating-card__coming-soon">(Coming Soon)</span>
  </button>
</footer>
```

**Step 2:** Add CSS for disabled state

```css
.node-floating-card__profile-button--disabled {
  background: var(--color-text-muted, #8b8579);
  cursor: not-allowed;
  opacity: 0.6;
}

.node-floating-card__profile-button--disabled:hover {
  background: var(--color-text-muted, #8b8579);
  transform: none;
}

.node-floating-card__coming-soon {
  font-size: 0.75rem;
  font-weight: normal;
  opacity: 0.8;
}
```

**Step 3:** Update SocialCirclesView.vue to remove the toast

Remove or comment out the `handleViewProfile` function since button is now disabled.

**Step 4:** Run tests and commit

```bash
npm run --prefix frontend test
npm run --prefix frontend lint
git add frontend/src/components/socialcircles/NodeFloatingCard.vue
git add frontend/src/views/SocialCirclesView.vue
git commit -m "fix(social-circles): Disable View Full Profile button

Button is now disabled with 'Coming Soon' indicator until
entity-detail route is implemented.

Closes #1391"
```

---

## Worktree 4: Timeline/URL

**Branch:** `feat/2.0/timeline-url`

### Task 4.1: Add v-model support to TimelineSlider (#1369)

**Step 1:** Read current TimelineSlider implementation

**Step 2:** Implement proper v-model pattern

```typescript
// Update props
interface Props {
  modelValue?: number;
  // Keep currentYear as alias for backwards compat
  currentYear?: number;
  minYear: number;
  maxYear: number;
  isPlaying?: boolean;
}

const props = withDefaults(defineProps<Props>(), {
  isPlaying: false,
});

const emit = defineEmits<{
  "update:modelValue": [year: number];
  "update:isPlaying": [isPlaying: boolean];
  // Keep old events for backwards compat
  "year-change": [year: number];
  "play-toggle": [];
}>();

// Computed for the actual year value
const effectiveYear = computed(() => props.modelValue ?? props.currentYear ?? props.minYear);

// Update both old and new event styles
function updateYear(year: number) {
  emit("update:modelValue", year);
  emit("year-change", year);
}
```

**Step 3:** Write test

```typescript
describe("v-model support", () => {
  it("should emit update:modelValue on year change", async () => {
    const wrapper = mount(TimelineSlider, {
      props: { modelValue: 1850, minYear: 1800, maxYear: 1900 },
    });

    // Simulate slider change
    const slider = wrapper.find('input[type="range"]');
    await slider.setValue(1860);

    expect(wrapper.emitted("update:modelValue")).toBeTruthy();
    expect(wrapper.emitted("update:modelValue")![0]).toEqual([1860]);
  });
});
```

**Step 4:** Run tests and commit

```bash
npm run --prefix frontend test -- --run TimelineSlider
git add frontend/src/components/socialcircles/TimelineSlider.vue
git commit -m "feat(social-circles): Add v-model support to TimelineSlider

Implements proper v-model pattern with modelValue prop and
update:modelValue emit. Maintains backwards compatibility
with currentYear prop.

Closes #1369"
```

---

### Task 4.2: Reduce URL debounce and pause during playback (#1373)

**Step 1:** Update useUrlState.ts

```typescript
// Change debounce from 300ms to 100ms
// frontend/src/composables/socialcircles/useUrlState.ts

// Add isPlaying parameter to updateUrl
function updateUrl(params: {
  filters?: FilterState;
  selectedNode?: NodeId | null;
  year?: number;
  isPlaying?: boolean;  // New parameter
}) {
  // Skip URL updates during playback
  if (params.isPlaying) {
    return;
  }

  if (updateTimeout) clearTimeout(updateTimeout);

  updateTimeout = setTimeout(() => {
    // ... existing logic
  }, 100);  // Reduced from 300ms
}
```

**Step 2:** Update ANIMATION constant

```typescript
// frontend/src/constants/socialCircles.ts
export const ANIMATION = {
  // ...
  debounceUrl: 100,  // Changed from 300
} as const;
```

**Step 3:** Update useSocialCircles to pass isPlaying

Ensure the main composable passes `isPlaying` to `updateUrl` calls.

**Step 4:** Run tests and commit

```bash
npm run --prefix frontend test
git add frontend/src/composables/socialcircles/useUrlState.ts
git add frontend/src/constants/socialCircles.ts
git commit -m "perf(social-circles): Reduce URL debounce, pause during playback

- Reduce debounce from 300ms to 100ms for faster URL sync
- Skip URL updates during timeline playback to avoid spam

Closes #1373"
```

---

## Worktree 5: Types/Constants

**Branch:** `feat/2.0/types-constants`

### Task 5.1: Use satisfies for TIER_MAP (#1387)

**Step 1:** Update formatters.ts

```typescript
// frontend/src/utils/socialCircles/formatters.ts

const TIER_MAP = {
  TIER_1: { label: "Premier", stars: 3, tooltip: "Tier 1 - Premier Figure" },
  TIER_2: { label: "Established", stars: 2, tooltip: "Tier 2 - Established Figure" },
  TIER_3: { label: "Known", stars: 1, tooltip: "Tier 3 - Known Figure" },
} as const satisfies Record<string, TierDisplay>;
```

**Step 2:** Run type check and tests

```bash
npm run --prefix frontend type-check
npm run --prefix frontend test -- --run formatters
```

**Step 3:** Commit

```bash
git add frontend/src/utils/socialCircles/formatters.ts
git commit -m "refactor(social-circles): Use satisfies for TIER_MAP type safety

Ensures TIER_MAP values match TierDisplay while preserving
literal type inference for better autocomplete.

Closes #1387"
```

---

### Task 5.2: Remove HoveredEdgeData type duplication (#1366)

**Step 1:** Create Mutable type utility

```typescript
// frontend/src/types/utils.ts

/** Make all properties of T mutable (remove readonly) */
export type Mutable<T> = { -readonly [P in keyof T]: T[P] };
```

**Step 2:** Update SocialCirclesView.vue

```typescript
// Replace the HoveredEdgeData interface (lines 134-144) with:
import type { Mutable } from "@/types/utils";
import type { ApiEdge } from "@/types/socialCircles";

type HoveredEdgeData = Mutable<ApiEdge>;
```

**Step 3:** Run type check and tests

```bash
npm run --prefix frontend type-check
npm run --prefix frontend test
```

**Step 4:** Commit

```bash
git add frontend/src/types/utils.ts
git add frontend/src/views/SocialCirclesView.vue
git commit -m "refactor(social-circles): Remove HoveredEdgeData type duplication

Use Mutable<ApiEdge> instead of manually duplicating all fields.
Changes to ApiEdge will now automatically propagate.

Closes #1366"
```

---

## Worktree 6: Frontend Misc

**Branch:** `feat/2.0/frontend-misc`

### Task 6.1: Lazy load Chart.js (#1359)

**Step 1:** Find Chart.js usage

```bash
# Already found: frontend/src/components/dashboard/StatisticsDashboard.vue
```

**Step 2:** Update to dynamic import

```typescript
// frontend/src/components/dashboard/StatisticsDashboard.vue

// Remove static import
// import { Chart } from 'chart.js';

// Add dynamic import in onMounted or setup
const chartInstance = ref<Chart | null>(null);

onMounted(async () => {
  const { Chart, registerables } = await import("chart.js");
  Chart.register(...registerables);

  // Now create chart
  chartInstance.value = new Chart(/* ... */);
});
```

**Step 3:** Run build to verify chunk splitting

```bash
npm run --prefix frontend build
```

**Step 4:** Commit

```bash
git add frontend/src/components/dashboard/
git commit -m "perf: Lazy load Chart.js only on dashboard

Use dynamic import to load Chart.js (~46KB) only when
Dashboard component mounts. Reduces initial bundle for
Social Circles and other non-chart pages.

Closes #1359"
```

---

### Task 6.2: Replace magic number in connection filter (#1368)

**Step 1:** Add constant

```typescript
// frontend/src/constants/socialCircles.ts

/** All connection types for filter validation */
export const ALL_CONNECTION_TYPES: ConnectionType[] = [
  "publisher",
  "shared_publisher",
  "binder",
];
```

**Step 2:** Update useUrlState.ts line 82

```typescript
import { ALL_CONNECTION_TYPES } from "@/constants/socialCircles";

// Change from:
if (f.connectionTypes.length < 3) {

// To:
if (f.connectionTypes.length < ALL_CONNECTION_TYPES.length) {
```

**Step 3:** Commit

```bash
git add frontend/src/constants/socialCircles.ts
git add frontend/src/composables/socialcircles/useUrlState.ts
git commit -m "refactor(social-circles): Replace magic number with constant

Use ALL_CONNECTION_TYPES.length instead of hardcoded 3.
More maintainable if connection types change.

Closes #1368"
```

---

### Task 6.3: Export menu click outside (#1375)

**Step 1:** Add click-outside handling to ExportMenu.vue

```typescript
import { onClickOutside } from "@vueuse/core";

const menuRef = ref<HTMLElement | null>(null);
const isOpen = ref(false);

onClickOutside(menuRef, () => {
  isOpen.value = false;
});
```

**Step 2:** Update template

```vue
<div ref="menuRef" class="export-menu">
  <!-- ... menu content -->
</div>
```

**Step 3:** Write test

```typescript
it("should close when clicking outside", async () => {
  const wrapper = mount(ExportMenu);
  await wrapper.find("button").trigger("click"); // Open menu
  expect(wrapper.find(".export-menu__dropdown").exists()).toBe(true);

  // Click outside
  document.body.click();
  await nextTick();

  expect(wrapper.find(".export-menu__dropdown").exists()).toBe(false);
});
```

**Step 4:** Commit

```bash
git add frontend/src/components/socialcircles/ExportMenu.vue
git commit -m "fix(social-circles): Close export menu on click outside

Use vueuse onClickOutside for better UX.

Closes #1375"
```

---

### Task 6.4: Document useNetworkData cache (#1365)

**Step 1:** Add documentation to composable

```typescript
// frontend/src/composables/socialcircles/useNetworkData.ts

/**
 * useNetworkData - Fetches and caches social circles network data.
 *
 * ## Cache Behavior
 *
 * This composable uses **instance-scoped caching**:
 * - Each component instance gets its own cache
 * - Navigating away destroys the cache
 * - Returning to the page triggers a fresh fetch
 *
 * This is intentional for several reasons:
 * 1. Prevents stale data from persisting across sessions
 * 2. Avoids complex invalidation logic for user/auth changes
 * 3. The 5-minute TTL would rarely be useful with navigation patterns
 *
 * If cross-navigation caching is needed in the future, consider:
 * - Pinia store for reactive state management
 * - Module-level cache with auth-aware invalidation
 */
```

**Step 2:** Commit

```bash
git add frontend/src/composables/socialcircles/useNetworkData.ts
git commit -m "docs(social-circles): Document useNetworkData cache behavior

Explains instance-scoped caching design decision and
alternatives for future consideration.

Closes #1365"
```

---

### Task 6.5: SVG gradient deduplication (#1388)

**Step 1:** This is low priority and complex. Document as future optimization.

```typescript
// Create issue comment instead of implementation
```

**Step 2:** Close issue with explanation

```bash
gh issue comment 1388 --body "After review, SVG gradient deduplication would require:
1. Build-time SVG optimization (svgo)
2. Or runtime sprite sheet generation

The 12 SVGs total ~5KB, so the optimization benefit is minimal.
Closing as won't-fix unless bundle size becomes a concern.

Alternative: Add svgo to build pipeline in a future optimization pass."

gh issue close 1388 --reason "not planned"
```

---

## Worktree 7: Tests

**Branch:** `feat/2.0/tests`

### Task 7.1: Add truncation behavior tests (#1370)

**Step 1:** Write comprehensive tests

```python
# backend/tests/api/v1/test_social_circles.py

class TestTruncationBehavior:
    """Tests for the truncated flag in social circles response."""

    def test_truncated_false_when_under_limit(self, client, db_session, create_book):
        """truncated should be False when under MAX_BOOKS limit."""
        create_book(status="ON_HAND")

        response = client.get("/api/v1/social-circles/")
        assert response.status_code == 200
        assert response.json()["meta"]["truncated"] == False

    def test_truncated_true_when_at_limit(self, client, db_session, create_book):
        """truncated should be True when hitting max_books limit."""
        # Use small max_books for test
        for i in range(150):
            create_book(title=f"Book {i}", status="ON_HAND")

        response = client.get("/api/v1/social-circles/?max_books=100")
        assert response.status_code == 200
        data = response.json()

        assert data["meta"]["truncated"] == True
        assert data["meta"]["total_books"] == 100
```

**Step 2:** Run tests

```bash
poetry run pytest tests/api/v1/test_social_circles.py -v -k "truncat"
```

**Step 3:** Commit

```bash
git add backend/tests/
git commit -m "test(social-circles): Add truncation behavior tests

Verifies truncated flag is correctly set when
hitting max_books limit.

Closes #1370"
```

---

### Task 7.2: Add useNetworkSelection edge case tests (#1390)

**Step 1:** Add edge case tests

```typescript
// frontend/src/composables/socialcircles/__tests__/useNetworkSelection.test.ts

describe("edge cases", () => {
  it("should handle toggleSelectNode with non-existent nodeId", () => {
    const { toggleSelectNode, selectedNode } = useNetworkSelection();

    // Should not throw
    toggleSelectNode("nonexistent:123");

    // Selection should remain null
    expect(selectedNode.value).toBeNull();
  });

  it("should handle selectEdge with missing source/target nodes", () => {
    const { selectEdge, setNodesAndEdges, selectedEdge } = useNetworkSelection();

    // Set up with only one node
    setNodesAndEdges(
      [{ id: "author:1", name: "Test", type: "author" }],
      [{ id: "e:1", source: "author:1", target: "author:2" }]  // author:2 doesn't exist
    );

    // Should not throw, but edge won't be fully selectable
    selectEdge("e:1");
    expect(selectedEdge.value).toBeDefined();
  });

  it("should handle methods called before setNodesAndEdges", () => {
    const { toggleSelectNode, selectEdge, highlightedNodes } = useNetworkSelection();

    // Should not throw when called before initialization
    toggleSelectNode("author:1");
    selectEdge("e:1");

    expect(highlightedNodes.value).toEqual([]);
  });
});
```

**Step 2:** Run tests

```bash
npm run --prefix frontend test -- --run useNetworkSelection
```

**Step 3:** Commit

```bash
git add frontend/src/composables/socialcircles/__tests__/
git commit -m "test(social-circles): Add edge case tests for useNetworkSelection

Tests:
- Non-existent nodeId handling
- Missing source/target nodes in edges
- Methods called before initialization

Closes #1390"
```

---

### Task 7.3: Create test fixtures infrastructure (#1382)

**Step 1:** Create fixtures file

```typescript
// frontend/src/test/fixtures/socialCircles.ts

import type { ApiNode, ApiEdge, ConnectionType, NodeType } from "@/types/socialCircles";

export const mockAuthor1: ApiNode = {
  id: "author:1",
  entity_id: 1,
  name: "Charles Dickens",
  type: "author" as NodeType,
  birth_year: 1812,
  death_year: 1870,
  era: "victorian",
  tier: "TIER_1",
  book_count: 15,
  book_ids: [1, 2, 3, 4, 5],
};

export const mockAuthor2: ApiNode = {
  id: "author:2",
  entity_id: 2,
  name: "William Thackeray",
  type: "author" as NodeType,
  birth_year: 1811,
  death_year: 1863,
  era: "victorian",
  tier: "TIER_2",
  book_count: 8,
  book_ids: [6, 7, 8],
};

export const mockPublisher1: ApiNode = {
  id: "publisher:1",
  entity_id: 1,
  name: "Chapman & Hall",
  type: "publisher" as NodeType,
  tier: "TIER_1",
  book_count: 20,
  book_ids: [1, 2, 6],
};

export const mockBinder1: ApiNode = {
  id: "binder:1",
  entity_id: 1,
  name: "RiviÃ¨re & Son",
  type: "binder" as NodeType,
  tier: "TIER_1",
  book_count: 5,
  book_ids: [1, 6],
};

export const mockEdge1: ApiEdge = {
  id: "e:author:1:publisher:1",
  source: "author:1",
  target: "publisher:1",
  type: "publisher" as ConnectionType,
  strength: 5,
  evidence: "Published 5 works",
  shared_book_ids: [1, 2],
};

export const mockEdge2: ApiEdge = {
  id: "e:author:1:author:2",
  source: "author:1",
  target: "author:2",
  type: "shared_publisher" as ConnectionType,
  strength: 3,
  evidence: "Both published by Chapman & Hall",
};

export const mockNodes: ApiNode[] = [
  mockAuthor1,
  mockAuthor2,
  mockPublisher1,
  mockBinder1,
];

export const mockEdges: ApiEdge[] = [mockEdge1, mockEdge2];
```

**Step 2:** Create MSW handlers

```typescript
// frontend/src/test/mocks/socialCirclesHandlers.ts

import { http, HttpResponse } from "msw";
import { mockNodes, mockEdges } from "../fixtures/socialCircles";

export const socialCirclesHandlers = [
  http.get("*/api/v1/social-circles/", () => {
    return HttpResponse.json({
      nodes: mockNodes,
      edges: mockEdges,
      meta: {
        total_books: 100,
        total_authors: 2,
        total_publishers: 1,
        total_binders: 1,
        date_range: [1800, 1900],
        truncated: false,
      },
    });
  }),

  http.get("*/api/v1/social-circles/health", () => {
    return HttpResponse.json({
      status: "healthy",
      latency_ms: 150,
      checks: {
        node_counts: { status: "healthy", authors: 2, publishers: 1, binders: 1 },
        edge_counts: { status: "healthy", publisher: 1, shared_publisher: 1, binder: 0 },
        query_performance: { status: "healthy", build_time_ms: 150 },
      },
    });
  }),
];
```

**Step 3:** Update existing tests to use fixtures

**Step 4:** Commit

```bash
git add frontend/src/test/
git commit -m "test(social-circles): Add test fixtures infrastructure

Creates:
- Mock entities (authors, publishers, binders)
- Mock edges
- MSW handlers for API mocking

Enables consistent test data across test files.

Closes #1382"
```

---

### Task 7.4: Performance validation (#1380)

**Step 1:** Create performance test file

```typescript
// frontend/src/components/socialcircles/__tests__/performance.test.ts

describe("Detail Panel Performance", () => {
  it("should render NodeFloatingCard within 16ms", async () => {
    const start = performance.now();

    const wrapper = mount(NodeFloatingCard, {
      props: {
        node: mockAuthor1,
        nodePosition: { x: 100, y: 100 },
        viewportSize: { width: 1920, height: 1080 },
        edges: mockEdges,
        nodes: mockNodes,
        isOpen: true,
      },
    });

    await nextTick();
    const duration = performance.now() - start;

    expect(duration).toBeLessThan(16); // 60fps frame budget
    wrapper.unmount();
  });

  it("should not leak memory on repeated open/close", async () => {
    const wrapper = mount(NodeFloatingCard, {
      props: {
        node: mockAuthor1,
        nodePosition: { x: 100, y: 100 },
        viewportSize: { width: 1920, height: 1080 },
        edges: mockEdges,
        nodes: mockNodes,
        isOpen: false,
      },
    });

    // Open and close 20 times
    for (let i = 0; i < 20; i++) {
      await wrapper.setProps({ isOpen: true });
      await nextTick();
      await wrapper.setProps({ isOpen: false });
      await nextTick();
    }

    // If no memory leak, this should complete without hanging
    wrapper.unmount();
  });
});
```

**Step 2:** Run performance tests

```bash
npm run --prefix frontend test -- --run performance
```

**Step 3:** Commit

```bash
git add frontend/src/components/socialcircles/__tests__/performance.test.ts
git commit -m "test(social-circles): Add performance validation tests

Validates:
- Render within 16ms frame budget
- No memory leaks on repeated open/close

Closes #1380"
```

---

## Merge Strategy

After all worktrees complete:

1. **Merge each worktree to staging** (squash)
   ```bash
   gh pr create --base staging --head feat/2.0/backend-api
   gh pr merge N --squash
   ```

2. **Run full test suite on staging**
   ```bash
   npm run --prefix frontend test
   poetry run pytest
   ```

3. **Deploy to staging and validate**
   ```bash
   gh run watch
   curl https://staging.api.bluemoxon.com/api/v1/social-circles/health
   ```

4. **Promote staging to main**
   ```bash
   gh pr create --base main --head staging --title "chore: Promote Phase 2.0 quality fixes"
   gh pr merge N --merge
   ```

---

## Issue Closure

After all tasks complete, close the issues:

```bash
gh issue close 1357 1358 1359 1363 1364 1365 1366 1367 1368 1369 1370 1372 1373 1374 1375 1380 1382 1385 1386 1387 1388 1389 1390 1391 1393
```
